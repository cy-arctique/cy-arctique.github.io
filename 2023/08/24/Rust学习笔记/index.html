<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="pragma" content="no-cache">
  <meta http-equiv="cache-control" content="no-cache">
  <meta http-equiv="expires" content="0">
  
  <title>Rust学习笔记 | Arctique</title>
  <meta name="author" content="Arctique">
  
  <meta name="description" content="2023.09.14持续更新笔记,主要是Rust的一些进阶语法">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="Rust学习笔记"/>
  <meta property="og:site_name" content="Arctique"/>

  
    <meta property="og:image" content=""/>
  

  
    <link rel="alternative" href="/atom.xml" title="Arctique" type="application/atom+xml">
  
  
    <link href="/favicon.png" rel="icon">
  
  
  <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/prism.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  




<meta name="generator" content="Hexo 6.3.0"></head>

 <body>  
  <nav id="main-nav" class="navbar navbar-inverse navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
		<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
	  <a class="navbar-brand" href="/">Arctique</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
			<a href="/archives" title="All the articles.">
			  <i class="fa fa-archive"></i>Archives
			</a>
		  </li>
		  
		  <li>
			<a href="/categories" title="All the categories.">
			  <i class="fa fa-folder"></i>Categories
			</a>
		  </li>
		  
		  <li>
			<a href="/tags" title="All the tags.">
			  <i class="fa fa-tags"></i>Tags
			</a>
		  </li>
		  
		  <li>
			<a href="/about" title="About me.">
			  <i class="fa fa-user"></i>About
			</a>
		  </li>
		  
		  <li>
			<a href="/atom.xml" title="Subscribe me.">
			  <i class="fa fa-rss"></i>RSS
			</a>
		  </li>
		  
		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
  	<div class="content">
    	 


	
		<div class="page-header">
			<h1> Rust学习笔记</h1>
		</div>
	



<div class="row post">
	<!-- cols -->
	
	<div id="top_meta"></div>
	<div class="col-md-9">
	

	<!-- content -->
	<div class="mypage">		
	  
		 <div class="alert alert-success description">
			<i class="fa fa-info-circle"></i> 2023.09.14持续更新笔记,主要是Rust的一些进阶语法
		 </div> <!-- alert -->
	  		

	  <h2 id="Rust网页版ide"><a href="#Rust网页版ide" class="headerlink" title="Rust网页版ide"></a>Rust网页版ide</h2><p><code>https://play.rust-lang.org/</code></p>
<h2 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h2><h3 id="RustUp相关"><a href="#RustUp相关" class="headerlink" title="RustUp相关"></a>RustUp相关</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 显示当前安装的工具链信息</span>
rustup show
<span class="token comment"># 检查安装更新</span>
rustup update
<span class="token comment"># 卸载</span>
rustup self uninstall
<span class="token comment"># 设置当前默认工具链</span>
rustup default stable-x86_64-pc-windows-gnu
<span class="token comment"># 查看帮助</span>
rustup <span class="token parameter variable">-h</span>

<span class="token comment"># -------------------------->配置工具链</span>
<span class="token comment"># 查看工具链</span>
rustup toolchain list
<span class="token comment"># 安装工具链</span>
rustup toolchain <span class="token function">install</span> stable-x86_64-pc-windows-gnu
<span class="token comment"># 卸载工具链</span>
rustup toolchain uninstall stable-x86_64-pc-windows-gnu
<span class="token comment"># 设置自定义工具链</span>
rustup toolchain <span class="token function">link</span> <span class="token operator">&lt;</span>toolchain-name<span class="token operator">></span> <span class="token string">"&lt;toolchain-path>"</span>

<span class="token comment"># -------------------------->配置一个目录以及其子目录的默认工具链</span>
<span class="token comment"># 查看已设置的默认工具链</span>
rustup override list
<span class="token comment"># 设置该目录以及其子目录的默认工具链</span>
rustup override <span class="token builtin class-name">set</span> <span class="token operator">&lt;</span>toolchain<span class="token operator">></span> <span class="token parameter variable">--path</span> <span class="token operator">&lt;</span>path<span class="token operator">></span>
<span class="token comment"># 取消目录以及其子目录的默认工具链</span>
rustup override <span class="token builtin class-name">unset</span> <span class="token parameter variable">--path</span> <span class="token operator">&lt;</span>path<span class="token operator">></span>

<span class="token comment"># -------------------------->配置工具链的可用目标</span>
<span class="token comment"># 查看目标列表</span>
rustup target list
<span class="token comment"># 安装目标</span>
rustup target <span class="token function">add</span> <span class="token operator">&lt;</span>target<span class="token operator">></span>
<span class="token comment"># 卸载目标</span>
rustup target remove <span class="token operator">&lt;</span>target<span class="token operator">></span>
<span class="token comment"># 为特定工具链安装目标</span>
rustup target <span class="token function">add</span> <span class="token parameter variable">--toolchain</span> <span class="token operator">&lt;</span>toolchain<span class="token operator">></span> <span class="token operator">&lt;</span>target<span class="token operator">></span>

<span class="token comment"># -------------------------->配置 rustup 安装的组件</span>
<span class="token comment"># 查看可用组件</span>
rustup component list
<span class="token comment"># 安装组件</span>
rustup component <span class="token function">add</span> <span class="token operator">&lt;</span>component<span class="token operator">></span>
<span class="token comment"># 卸载组件</span>
rustup component remove <span class="token operator">&lt;</span>component<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="配置工具链安装位置"><a href="#配置工具链安装位置" class="headerlink" title="配置工具链安装位置"></a>配置工具链安装位置</h3><p>在系统环境变量中添加如下变量：</p>
<ul>
<li>CARGO_HOME - 指定cargo的安装目录</li>
<li>RUSTUP_HOME - 指定rustup的安装目录</li>
</ul>
<p>默认分别安装到用户目录下的<code>.cargo</code> 和<code>.rustup</code> 目录</p>
<h3 id="配置国内镜像"><a href="#配置国内镜像" class="headerlink" title="配置国内镜像"></a>配置国内镜像</h3><p>在系统环境变量中添加如下变量(选一个就可以，可以组合): </p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 清华大学</span>
RUSTUP_DIST_SERVER：https://mirrors.tuna.tsinghua.edu.cn/rustup
RUSTUP_UPDATE_ROOT：https://mirrors.tuna.tsinghua.edu.cn/rustup/rustup
<span class="token comment"># 中国科学技术大学</span>
RUSTUP_DIST_SERVER：https://mirrors.ustc.edu.cn/rust-static
RUSTUP_UPDATE_ROOT：https://mirrors.ustc.edu.cn/rust-static/rustup<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="配置-cargo-国内镜像"><a href="#配置-cargo-国内镜像" class="headerlink" title="配置 cargo 国内镜像"></a>配置 cargo 国内镜像</h3><p>在 cargo 安装目录下新建<code>config</code> 文件(注意 config 没有任何后缀)，文件内容如下: </p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>source.crates-io<span class="token punctuation">]</span>
registry <span class="token operator">=</span> <span class="token string">"https://github.com/rust-lang/crates.io-index"</span>
replace-with <span class="token operator">=</span> <span class="token string">'tuna'</span>

<span class="token comment"># 清华大学</span>
<span class="token punctuation">[</span>source.tuna<span class="token punctuation">]</span>
registry <span class="token operator">=</span> <span class="token string">"https://mirrors.tuna.tsinghua.edu.cn/git/crates.io-index.git"</span>

<span class="token comment"># 中国科学技术大学</span>
<span class="token punctuation">[</span>source.ustc<span class="token punctuation">]</span>
registry <span class="token operator">=</span> <span class="token string">"git://mirrors.ustc.edu.cn/crates.io-index"</span>
<span class="token comment"># 设置代理</span>
<span class="token punctuation">[</span>http<span class="token punctuation">]</span>
proxy <span class="token operator">=</span> <span class="token string">"127.0.0.1:8889"</span>
<span class="token punctuation">[</span>https<span class="token punctuation">]</span>
proxy <span class="token operator">=</span> <span class="token string">"127.0.0.1:8889"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="使用Rust模块系统管理代码"><a href="#使用Rust模块系统管理代码" class="headerlink" title="使用Rust模块系统管理代码"></a>使用Rust模块系统管理代码</h2><p>Rust 提供了一系列功能，可帮助你管理和组织代码。 这些功能称为“Rust 模块系统”。 系统由 Crate、模块、路径和工具组成，以与那些项结合使用</p>
<ul>
<li>箱：Rust 箱是一个编译单元。 它是 Rust 编译器可以运行的最小代码段。 箱中的代码一起编译以创建二进制可执行文件或库。 在 Rust 中，仅将箱编译为可重复使用的单元。 箱包含具有隐式未命名顶级模块的 Rust 模块的层次结构</li>
<li>模块：Rust 模块通过让你管理箱内单个代码项的范围来帮助你组织程序。 结合使用的相关代码项或项可以分组到相同模块中。 递归代码定义可以跨越其他模块</li>
<li>路径：在 Rust 中，可以使用路径来命名代码中的项。 例如，路径可以是一个数据定义（例如，矢量、代码函数，甚至是模块）。 模块功能还可帮助你控制路径的隐私。 可以指定可公开访问的代码部分和私有部分。 通过该功能可以隐藏实现详细信息</li>
</ul>
<h2 id="使用Rust箱和库"><a href="#使用Rust箱和库" class="headerlink" title="使用Rust箱和库"></a>使用Rust箱和库</h2><ul>
<li>Rust 标准库。 在 Rust 练习中，你将会注意到以下模块：<ul>
<li>std::collections - 集合类型的定义，如 HashMap</li>
<li>std::env - 用于处理环境的函数</li>
<li>std::fmt - 控制输出格式的功能</li>
<li>std::fs - 用于处理文件系统的功能</li>
<li>std::io - 用于处理输入&#x2F;输出的定义和功能</li>
<li>std::path - 支持处理文件系统路径数据的定义和功能</li>
</ul>
</li>
<li>structopt - 用于轻松分析命令行参数的第三方箱</li>
<li>chrono - 用于处理日期和时间数据的第三方箱</li>
<li>regex - 用于处理正则表达式的第三方箱</li>
<li>serde - 适用于 Rust 数据结构的序列化和反序列化操作的第三方箱</li>
</ul>
<h2 id="使用Cargo创建和管理项目"><a href="#使用Cargo创建和管理项目" class="headerlink" title="使用Cargo创建和管理项目"></a>使用Cargo创建和管理项目</h2><ul>
<li>使用 cargo new 命令创建新的项目模板</li>
<li>使用 cargo build 编译项目</li>
<li>使用 cargo run 命令编译并运行项目</li>
<li>使用 cargo test 命令测试项目</li>
<li>使用 cargo check 命令检查项目类型</li>
<li>使用 cargo doc 命令编译项目的文档</li>
<li>使用 cargo publish 命令将库发布到 crates.io</li>
<li>通过将箱的名称添加到 Cargo.toml 文件来将依赖箱添加到项目</li>
</ul>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>Rust支持三种结构类型：经典结构、元组结构和单元结构。这些结构类型支持使用各种方式对数据进行分组和处理</p>
<ul>
<li>“经典C结构”最为常用。结构中的每个字段都具有名称和数据类型。定义经典结构后，可以使用语法<struct>.<field>访问结构中的字段</li>
<li>元组结构类似于经典结构，但字段没有名称。要访问元组结构中的字段，请使用索引元组时所用的语法：<struct>.<index>。与元组一样，元组结构中的索引值从0开始</li>
<li>“单元结构”最常用作标记<pre class="line-numbers language-Rust" data-language="Rust"><code class="language-Rust">struct Student &#123;
    name: String,
    level: u8,
    remote: bool
&#125;

struct Grades(char, char, u8, f32);

struct Unit;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
<h2 id="创建和使用数组"><a href="#创建和使用数组" class="headerlink" title="创建和使用数组"></a>创建和使用数组</h2><h3 id="定义数组"><a href="#定义数组" class="headerlink" title="定义数组"></a>定义数组</h3><ul>
<li>未指定长度的逗号分隔的值列表</li>
<li>初始值后跟一个分号，然后是数组长度</li>
</ul>
<pre class="line-numbers language-Rust" data-language="Rust"><code class="language-Rust">&#x2F;&#x2F; Declare array, initialize all values, compiler infers length &#x3D; 7
let days &#x3D; [&quot;Sunday&quot;, &quot;Monday&quot;, &quot;Tuesday&quot;, &quot;Wednesday&quot;, &quot;Thursday&quot;, &quot;Friday&quot;, &quot;Saturday&quot;];
  
&#x2F;&#x2F; Declare array, initialize all values to 0, length &#x3D; 5
let bytes &#x3D; [0; 5];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在编译时，数组的签名定义为 <code>[T; size]</code>：</p>
<ul>
<li><code>T</code>是数组中所有元素的数据类型</li>
<li><code>size</code>是表示数组长度的非负整数</li>
</ul>
<p>该签名揭示有关数组的两个重要特征:</p>
<ul>
<li>数组的每个元素都具有相同的数据类型。 数据类型永远不会更改</li>
<li>数组大小是固定的。 长度永远不会更改</li>
</ul>
<p>仅数组中元素的值可随时间而更改。 数据类型和元素数量（长度）均保持不变。 只有这些值可以更改</p>
<h3 id="读取数组的值"><a href="#读取数组的值" class="headerlink" title="读取数组的值"></a>读取数组的值</h3><p>数组中的元素从 0 开始隐式编号。 我们在表达式 <code>&lt;array&gt;[&lt;index&gt;]</code> 中使用索引来访问的数组中的元素。 例如，<code>my_array[0]</code> 访问 <code>my_array</code> 变量中索引 0 位置的元素。 该表达式返回该索引位置的数组元素的值</p>
<pre class="line-numbers language-Rust" data-language="Rust"><code class="language-Rust">&#x2F;&#x2F; Days of the week
let days &#x3D; [&quot;Sunday&quot;, &quot;Monday&quot;, &quot;Tuesday&quot;, &quot;Wednesday&quot;, &quot;Thursday&quot;, &quot;Friday&quot;, &quot;Saturday&quot;];

&#x2F;&#x2F; Get the first day of the week
let first &#x3D; days[0];

&#x2F;&#x2F; Get the second day of the week
let second &#x3D; days[1];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><p>Vector和数组一样，可以使用索引访问元素。<code>mut</code> 可变Vector添加元素可以使用 <code>push</code>函数，删除Vector最后一个元素可以使用 <code>pop</code>函数</p>
<h2 id="if-else"><a href="#if-else" class="headerlink" title="if else"></a>if else</h2><p>Rust中的<code>if-else</code> 语句块是可以充当表达式的</p>
<pre class="line-numbers language-Rust" data-language="Rust"><code class="language-Rust">let formal &#x3D; true;
let greeting &#x3D; if formal &#123; &#x2F;&#x2F; if used here as an expression
    &quot;Good day to you.&quot;     &#x2F;&#x2F; return a String
&#125; else &#123;
    &quot;Hey!&quot;                 &#x2F;&#x2F; return a String
&#125;;
println!(&quot;&#123;&#125;&quot;, greeting)   &#x2F;&#x2F; prints &quot;Good day to you.&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="合并多个测试条件"><a href="#合并多个测试条件" class="headerlink" title="合并多个测试条件"></a>合并多个测试条件</h3><p>可以将<code>if</code> 和<code>else</code> 组合在一起形成<code>else if</code> 表达式。可以在开头的<code>if</code> 条件后面和<code>else</code> 条件前面使用多个<code>else if</code>条件，这些条件是可选的</p>
<p>如果条件表达式的计算结果为<code>true</code>，则执行相应的操作块，跳过后面任何的<code>else if</code> 和<code>else</code> 块。如果条件表达式的结果为<code>false</code> ，则跳过相应的操作块。如果<code>if</code> 和 <code>else if</code> 条件的计算结果都是<code>false</code>，则执行所有的<code>else</code> 程序块</p>
<pre class="line-numbers language-Rust" data-language="Rust"><code class="language-Rust">let num &#x3D; 500; &#x2F;&#x2F; num variable can be set at some point in the program
let out_of_range: bool;
if num &lt; 0 &#123;
    out_of_range &#x3D; true;
&#125; else if num &#x3D;&#x3D; 0 &#123;
    out_of_range &#x3D; true;
&#125; else if num &gt; 512 &#123;
    out_of_range &#x3D; true;
&#125; else &#123;
    out_of_range &#x3D; false;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><ul>
<li>处理无法恢复的错误可以使用<code>panic!</code></li>
<li>如果值是可选或缺少值不是一种错误的情况，使用<code>Option</code> 枚举</li>
<li>当可能出现问题并且调用方法必须处理问题时，使用<code>Result</code> 枚举</li>
</ul>
<h3 id="使用Option类型来处理缺失"><a href="#使用Option类型来处理缺失" class="headerlink" title="使用Option类型来处理缺失"></a>使用Option类型来处理缺失</h3><p><code>Option&lt;T&gt;</code> 将自身列为两个变体之一：</p>
<pre class="line-numbers language-Rust" data-language="Rust"><code class="language-Rust">enum Option&lt;T&gt; &#123;
    None,     &#x2F;&#x2F; The value doesn&#96;t exist
    Some(T),  &#x2F;&#x2F; The value exists
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>Option&lt;T&gt;</code> 枚举声明的<code>&lt;T&gt;</code> 部分声明类型<code>T</code> 是通用的，将与<code>Option</code> 枚举的<code>Some</code> 变体相关联</p>
<p><code>None</code> 和<code>Some</code>不是类型，而是<code>Option&lt;T&gt;</code> 类型的变体。这表示在其他功能中，函数不能使用<code>Some</code> 或<code>None</code> 作为参数，而只能使用<code>Option&lt;T&gt;</code> 作为参数</p>
<h3 id="如何才能访问到Some-data-变体中的数据呢？"><a href="#如何才能访问到Some-data-变体中的数据呢？" class="headerlink" title="如何才能访问到Some(data) 变体中的数据呢？"></a>如何才能访问到<code>Some(data)</code> 变体中的数据呢？</h3><h4 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h4><p>Rust 中提供了一个功能强大的运算符，称为 <code>match</code>。 可利用该运算符，通过提供模式来控制程序流。 当 match 找到匹配的模式时，它会运行随该模式一起提供的代码</p>
<pre class="line-numbers language-Rust" data-language="Rust"><code class="language-Rust">let fruits &#x3D; vec![&quot;banana&quot;, &quot;apple&quot;, &quot;coconut&quot;, &quot;orange&quot;, &quot;strawberry&quot;];
for &amp;index in [0, 2, 99].iter() &#123;
    match fruits.get(index) &#123;
        Some(fruit_name) &#x3D;&gt; println!(&quot;It&#39;s a delicious &#123;&#125;!&quot;, fruit_name),
        None &#x3D;&gt; println!(&quot;There is no fruit! :(&quot;),
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="if-let-表达式"><a href="#if-let-表达式" class="headerlink" title="if let 表达式"></a>if let 表达式</h4><pre class="line-numbers language-Rust" data-language="Rust"><code class="language-Rust">let a_number: Option&lt;u8&gt; &#x3D; Some(7);
match a_number &#123;
    Some(7) &#x3D;&gt; println!(&quot;That&#39;s my lucky number!&quot;),
    _ &#x3D;&gt; &#123;&#125;,
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这种情况下，可以用所有其他模式之后添加<code>_</code> 通配符，以匹配任何其他模式</p>
<p>使用<code>if let</code> 压缩代码：</p>
<pre class="line-numbers language-Rust" data-language="Rust"><code class="language-Rust">let a_number: Option&lt;u8&gt; &#x3D; Some(7);
if let Some(7) &#x3D; a_number &#123;
    println!(&quot;That&#39;s my lucky number!&quot;);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="使用unwrap-和expect"><a href="#使用unwrap-和expect" class="headerlink" title="使用unwrap 和expect"></a>使用<code>unwrap</code> 和<code>expect</code></h4><p>可以使用<code>unwrap</code> 和<code>expect</code> 方法直接访问<code>Option</code> 类型的内部值。但是要小心，因为如果变体是<code>None</code>，则此方法会<code>panic</code></p>
<h3 id="使用Result-类型来处理错误"><a href="#使用Result-类型来处理错误" class="headerlink" title="使用Result 类型来处理错误"></a>使用Result 类型来处理错误</h3><p>Rust提供了用于返回和传播错误的<code>Result&lt;T, E&gt;</code> 枚举。按照惯例，<code>Ok(T)</code> 变量表示成功并包含一个值，而变量<code>Err(E)</code> 表示错误并包含一个错误值</p>
<pre class="line-numbers language-Rust" data-language="Rust"><code class="language-Rust">enum Result&lt;T, E&gt; &#123;
    Ok(T):  &#x2F;&#x2F; A value T was obtained.
    Err(E): &#x2F;&#x2F; An error of type E was encountered instead.
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>不同于描述缺少某个值的可能性<code>Option</code> 类型，<code>Result</code> 类型最适合在可能会失败的时候使用</p>
<p><code>Result</code> 类型还具有<code>unwrap</code> 和 <code>expect</code> 方法，这些方法执行以下操作之一：</p>
<ul>
<li>返回<code>Ok</code> 变量中的值</li>
<li>如果变体是<code>Err</code>，则导致程序<code>panic</code></li>
</ul>
<pre class="line-numbers language-Rust" data-language="Rust"><code class="language-Rust">#[derive(Debug)]
struct DivisionByZeroError;

fn safe_division(dividend: f64, divisor: f64) -&gt; Result&lt;f64, DivisionByZeroError&gt; &#123;
    if divisor &#x3D;&#x3D; 0.0 &#123;
        Err(DivisionByZeroError)
    &#125; else &#123;
        Ok(dividend &#x2F; divisor)
    &#125;
&#125;

fn main() &#123;
    println!(&quot;&#123;:?&#125;&quot;, safe_division(9.0, 3.0));
    println!(&quot;&#123;:?&#125;&quot;, safe_division(4.0, 0.0));
    println!(&quot;&#123;:?&#125;&quot;, safe_division(0.0, 2.0));
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>Rust最强大的两个功能：所有权和借用</p>
<h3 id="什么是所有权？"><a href="#什么是所有权？" class="headerlink" title="什么是所有权？"></a>什么是所有权？</h3><p>Rust包含用于管理内存的所有权系统。在编译时，所有权系统会检查一组规则，以确保所有权功能允许程序运行而不减慢速度</p>
<h4 id="作用域界定规则"><a href="#作用域界定规则" class="headerlink" title="作用域界定规则"></a>作用域界定规则</h4><p>在Rust中，与大多数编程语言一样，变量仅在特定的作用域内有效。在Rust中，作用域常常由大括号<code>&#123;&#125;</code> 表示。常见的作用域还包括函数体、<code>if</code>、<code>else</code> 和<code>match</code> 分支</p>
<p>在Rust中，“变量”通常称为“绑定”。这是因为Rust中的“变量”不是多变的，它们默认不可变，因此不会经常改变。相反，我们常常会想到与数据“绑定”的名称，所以称为“绑定”</p>
<p>假设一个<code>string</code> 变量，它是在某个作用域内定义的一个字符串：</p>
<pre class="line-numbers language-Rust" data-language="Rust"><code class="language-Rust">&#x2F;&#x2F; &#96;string&#96; is not valid and cannot be used here, because it&#39;s not yet declared.
&#123;
    let string &#x3D; String::from(&quot;ferris&quot;);   &#x2F;&#x2F; &#96;string&#96; is valid from this point forward.
    &#x2F;&#x2F; do stuff with &#96;string&#96;.
&#125;
&#x2F;&#x2F; this scope is now over, so &#96;string&#96; is no longer valid and cannot be used.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果尝试在<code>string</code> 的范围之外使用它，将会得到一下错误示例：</p>
<pre class="line-numbers language-Rust" data-language="Rust"><code class="language-Rust">&#123;
    let string &#x3D; String::from(&quot;ferris&quot;);
&#125;
println!(&quot;&#123;&#125;&quot;, string);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">error<span class="token punctuation">[</span>E0425<span class="token punctuation">]</span>: cannot <span class="token function">find</span> value <span class="token variable"><span class="token variable">`</span>string<span class="token variable">`</span></span> <span class="token keyword">in</span> this scope
     --<span class="token operator">></span> src/main.rs:5:20
      <span class="token operator">|</span>
    <span class="token number">5</span> <span class="token operator">|</span>     println<span class="token operator">!</span><span class="token punctuation">(</span><span class="token string">"&#123;&#125;"</span>, string<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token operator">|</span>                    ^^^^^^ not found <span class="token keyword">in</span> this scope<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="所有权和删除"><a href="#所有权和删除" class="headerlink" title="所有权和删除"></a>所有权和删除</h4><p>Rust给范围的概念增加了一个转折。当对象超出范围时，便会将其“删除”。删除变量会释放与其关联的所有资源。对于文件的变量，文件最终会被关闭。对于已分配了与其关联的内存的变量，内存将被释放</p>
<p>在Rust中，将绑定被删除时释放的内容与自己“关联”到一起的绑定将“拥有”这些内容</p>
<p>在上一个例子中，<code>string</code> 变量拥有与之关联的<code>String</code> 数据。<code>string</code> 本身拥有堆分配的内存，其中包含该字符串的字符。在作用域的末尾，<code>string</code> 被“删除”，它拥有的<code>String</code> 被删除，最后<code>String</code> 拥有的内存被释放</p>
<pre class="line-numbers language-Rust" data-language="Rust"><code class="language-Rust">&#123;
    let string &#x3D; String::from(&quot;ferris&quot;);
    &#x2F;&#x2F; string dropped here. The String data memory will be freed here.
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="移动语义"><a href="#移动语义" class="headerlink" title="移动语义"></a>移动语义</h4><p>有时，我们不希望在作用域末尾删除与变量的关联的内容。相反，我们希望将某个项的所有权从一个绑定转移到另一个绑定</p>
<pre class="line-numbers language-Rust" data-language="Rust"><code class="language-Rust">&#123;
    let string &#x3D; String::from(&quot;ferris&quot;);
    &#x2F;&#x2F; transfer ownership of string to the variable ferris.
    let ferris &#x3D; string;
    &#x2F;&#x2F; ferris dropped here. The string data memory will be freed here.
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>需要了解一个关键问题，那就是所有权一旦转移，旧变量将不再有效。当我们将<code>String</code> 的所有权从 <code>string</code> 转移到 <code>ferris</code> 之后，将无法再使用<code>string</code> 变量</p>
<p>如果我们尝试在将<code>String</code> 从<code>string</code> 移动到<code>ferris</code> 之后使用<code>string</code>，编译器将不会编译我们的代码：</p>
<pre class="line-numbers language-Rust" data-language="Rust"><code class="language-Rust">let string &#x3D; String::from(&quot;hello world&quot;);
let ferris &#x3D; string;
&#x2F;&#x2F; We&#39;ll try to use string after we&#39;ve moved ownership of the string data from string to ferris.
println!(&quot;&#123;&#125;&quot;, string);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">error<span class="token punctuation">[</span>E0382<span class="token punctuation">]</span>: borrow of moved value: <span class="token variable"><span class="token variable">`</span>string<span class="token variable">`</span></span>
 --<span class="token operator">></span> src/main.rs:4:20
  <span class="token operator">|</span>
<span class="token number">2</span> <span class="token operator">|</span>     <span class="token builtin class-name">let</span> string <span class="token operator">=</span> String::from<span class="token punctuation">(</span><span class="token string">"ferris"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token operator">|</span>         ------ move occurs because <span class="token variable"><span class="token variable">`</span>string<span class="token variable">`</span></span> has <span class="token builtin class-name">type</span> <span class="token variable"><span class="token variable">`</span>String<span class="token variable">`</span></span>, <span class="token function">which</span> does not implement the <span class="token variable"><span class="token variable">`</span>Copy<span class="token variable">`</span></span> trait
<span class="token number">3</span> <span class="token operator">|</span>     <span class="token builtin class-name">let</span> ferris <span class="token operator">=</span> string<span class="token punctuation">;</span>
  <span class="token operator">|</span>                  ------ value moved here
<span class="token number">4</span> <span class="token operator">|</span>     println<span class="token operator">!</span><span class="token punctuation">(</span><span class="token string">"&#123;&#125;"</span>, string<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token operator">|</span>                    ^^^^^^ value borrowed here after move<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>该结果被称为“移动后使用”编译错误</p>
<p>在Rust中，一个项一次只能拥有一段数据</p>
<h4 id="函数中的所有权"><a href="#函数中的所有权" class="headerlink" title="函数中的所有权"></a>函数中的所有权</h4><p>例子：将字符创作为参数传递给函数。将某个内容作为参数传递给函数，会将该内容移动到函数中</p>
<pre class="line-numbers language-Rust" data-language="Rust"><code class="language-Rust">fn process(input: String) &#123;&#125;

fn caller() &#123;
    let s &#x3D; String::from(&quot;hello world&quot;);
    process(s); &#x2F;&#x2F; Ownership of the string in &#96;s&#96; moved into &#96;process&#96;
    process(s); &#x2F;&#x2F; Error! ownership already moved.
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>编译器提醒<code>s</code> 已被移动</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">error<span class="token punctuation">[</span>E0382<span class="token punctuation">]</span>: use of moved value: <span class="token variable"><span class="token variable">`</span>s<span class="token variable">`</span></span>
     --<span class="token operator">></span> src/main.rs:6:13
      <span class="token operator">|</span>
    <span class="token number">4</span> <span class="token operator">|</span>     <span class="token builtin class-name">let</span> s <span class="token operator">=</span> String::from<span class="token punctuation">(</span><span class="token string">"Hello, world!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token operator">|</span>         - move occurs because <span class="token variable"><span class="token variable">`</span>s<span class="token variable">`</span></span> has <span class="token builtin class-name">type</span> <span class="token variable"><span class="token variable">`</span>String<span class="token variable">`</span></span>, <span class="token function">which</span> does not implement the <span class="token variable"><span class="token variable">`</span>Copy<span class="token variable">`</span></span> trait
    <span class="token number">5</span> <span class="token operator">|</span>     process<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> // Transfers ownership of <span class="token variable"><span class="token variable">`</span>s<span class="token variable">`</span></span> to <span class="token variable"><span class="token variable">`</span>process<span class="token variable">`</span></span>
      <span class="token operator">|</span>             - value moved here
    <span class="token number">6</span> <span class="token operator">|</span>     process<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> // Error<span class="token operator">!</span> ownership already transferred.
      <span class="token operator">|</span>             ^ value used here after move<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="复制而不是移动"><a href="#复制而不是移动" class="headerlink" title="复制而不是移动"></a>复制而不是移动</h4><pre class="line-numbers language-Rust" data-language="Rust"><code class="language-Rust">fn process(input: u32) &#123;&#125;

fn caller() &#123;
    let n &#x3D; 1u32;
    process(n); &#x2F;&#x2F; Ownership of the number in &#96;n&#96; copied into &#96;process&#96;
    process(n); &#x2F;&#x2F; &#96;n&#96; can be used again because it wasn&#96;t moved, it was copied
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>简单类型，如数字是“复制”类型。它们实现<code>Copy</code> 特征，这意味着它们被复制而不是移动。大多数简单类型都执行相同的操作。复制数字的成本低，因此复制这些值是有意义的。复制字符串、向量或其他复杂类型的成本可能高昂，因此它们没有实现<code>Copy</code> 特征，而是被移动</p>
<h4 id="复制不实现Copy-的类型"><a href="#复制不实现Copy-的类型" class="headerlink" title="复制不实现Copy 的类型"></a>复制不实现<code>Copy</code> 的类型</h4><p>解决上一个示例中所示错误的一种方法是：在移动类型之前，显式复制它们，这在Rust中称为克隆。调用<code>.clone</code> 会复制内存并生成一个新值。新值被移动，这意味着仍然可以使用旧值</p>
<pre class="line-numbers language-Rust" data-language="Rust"><code class="language-Rust">fn process(s: String) &#123;&#125;

fn caller() &#123;
    let s &#x3D; String::from(&quot;Hello world&quot;);
    process(s.clone()); &#x2F;&#x2F; Passing another value, cloned from &#96;s&#96;
    process(s); &#x2F;&#x2F; s was never moved and so it can still be used.
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这种方法可能有用，但会导致代码运行速度变慢，因此每次调用<code>clone</code> 都是对数据的一次完整复制。此方法通过包括内存分配或其他高成本的操作。可以使用引用来“借用”值，从而避免这些成本</p>
<h3 id="了解借用"><a href="#了解借用" class="headerlink" title="了解借用"></a>了解借用</h3><p>通过将所有权从一个变量转移到另一个变量来转移一个值的所有权。对于实现<code>Copy</code> 特征的类型，例如简单的值（如数字），所有权不能被转移</p>
<p>还可以使用克隆过程显式复制值。调用<code>clone</code> 方法并获取复制的新值，这样原始值未被移动且仍可使用</p>
<p>此类功能通过使用引用来提供，通过引用，可以“借用”一些值，而无需拥有它们</p>
<pre class="line-numbers language-Rust" data-language="Rust"><code class="language-Rust">let greeting &#x3D; String::from(&quot;hello&quot;);
let greeting_reference &#x3D; &amp;greeting; &#x2F;&#x2F; We borrow &#96;greeting&#96; but the string data is still owned by &#96;greeting&#96;
println!(&quot;Greeting: &#123;&#125;&quot;, greeting); &#x2F;&#x2F; We can still use &#96;greeting&#96;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><code>greeting</code> 是使用引用符号(<code>&amp;</code>) 借用的。变量<code>greeting_reference</code> 的类型为字符串引用(<code>&amp;String</code>)。由于只借用了<code>greeting</code>，并没有移动所有权，因此，在创建<code>greeting_reference</code> 之后仍然可以使用<code>greeting</code></p>
<h4 id="函数中的引用"><a href="#函数中的引用" class="headerlink" title="函数中的引用"></a>函数中的引用</h4><pre class="line-numbers language-Rust" data-language="Rust"><code class="language-Rust">fn print_greeting(message: &amp;String) &#123;
    println!(&quot;Greeting: &#123;&#125;&quot;, message);
&#125;

fn main() &#123;
    let greeting &#x3D; String::from(&quot;Hello&quot;);
    print_greeting(&amp;greeting); &#x2F;&#x2F; &#96;print_greeting&#96; takes a &#96;&amp;String&#96; not an owned &#96;String&#96; so we borrow &#96;greeting&#96;
    print_greeting(&amp;greeting); &#x2F;&#x2F; Since &#96;greeting&#96; didn&#39;t move into &#96;print_greeting&#96; we can use it again
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>通过借用，无需完全拥有某个值即可使用它。不过，借用值意味着并不能像完全拥有值那样执行权限范围内的所有操作</p>
<h4 id="改变借用的值"><a href="#改变借用的值" class="headerlink" title="改变借用的值"></a>改变借用的值</h4><pre class="line-numbers language-Rust" data-language="Rust"><code class="language-Rust">fn change(message: &amp;String) &#123;
  message.push_str(&quot;!&quot;); &#x2F;&#x2F; We try to add a &quot;!&quot; to the end of our message
&#125;

fn main() &#123;
  let greeting &#x3D; String::from(&quot;Hello&quot;);
  change(&amp;greeting); 
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码不能通过编译。收到的错误是：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">error<span class="token punctuation">[</span>E0596<span class="token punctuation">]</span>: cannot borrow <span class="token variable"><span class="token variable">`</span>*message<span class="token variable">`</span></span> as mutable, as it is behind a <span class="token variable"><span class="token variable">`</span><span class="token operator">&amp;</span><span class="token variable">`</span></span> reference
 --<span class="token operator">></span> src/main.rs:2:3
  <span class="token operator">|</span>
<span class="token number">1</span> <span class="token operator">|</span> fn change<span class="token punctuation">(</span>message: <span class="token operator">&amp;</span>String<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token operator">|</span>                    ------- help: consider changing this to be a mutable reference: <span class="token variable"><span class="token variable">`</span><span class="token operator">&amp;</span>mut String<span class="token variable">`</span></span>
<span class="token number">2</span> <span class="token operator">|</span>   message.push_str<span class="token punctuation">(</span><span class="token string">"!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> // We try to <span class="token function">add</span> a <span class="token string">"!"</span> to the end of our message
  <span class="token operator">|</span>   ^^^^^^^ <span class="token variable"><span class="token variable">`</span>message<span class="token variable">`</span></span> is a <span class="token variable"><span class="token variable">`</span><span class="token operator">&amp;</span><span class="token variable">`</span></span> reference, so the data it refers to cannot be borrowed as mutable<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="借用和可变引用"><a href="#借用和可变引用" class="headerlink" title="借用和可变引用"></a>借用和可变引用</h4><p>不可变引用和可变引用还有一个不同之处：会对我们生成Rust程序的方式有根本的影响。借用任何<code>T</code> 类型的值时，以下规则都适用：</p>
<p>代码必须同时实现以下任一定义，但不能同时实现这两个定义：</p>
<ul>
<li>一个或多个不可变引用（<code>&amp;T</code>）</li>
<li>恰好一个可变引用（<code>&amp;mut T</code>）</li>
</ul>
<h3 id="使用生命周期验证引用"><a href="#使用生命周期验证引用" class="headerlink" title="使用生命周期验证引用"></a>使用生命周期验证引用</h3><pre class="line-numbers language-Rust" data-language="Rust"><code class="language-Rust">fn main() &#123;
    let x;
    &#123;
        let y &#x3D; 42;
        x &#x3D; &amp;y; &#x2F;&#x2F; We store a reference to &#96;y&#96; in &#96;x&#96; but &#96;y&#96; is about to be dropped.
    &#125;
    println!(&quot;x: &#123;&#125;&quot;, x); &#x2F;&#x2F; &#96;x&#96; refers to &#96;y&#96; but &#96;y has been dropped!
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这段代码编译失败</p>
<pre class="line-numbers language-Rust" data-language="Rust"><code class="language-Rust">fn main() &#123;
    let x;                &#x2F;&#x2F; ---------+-- &#39;a
    &#123;                     &#x2F;&#x2F;          |
        let y &#x3D; 42;       &#x2F;&#x2F; -+-- &#39;b  |
        x &#x3D; &amp;y;           &#x2F;&#x2F;  |       |
    &#125;                     &#x2F;&#x2F; -+       |
    println!(&quot;x: &#123;&#125;&quot;, x); &#x2F;&#x2F;          |
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>内层 <code>&#39;b</code> 块的生存期比外层 <code>&#39;a</code> 块的生存期更短</p>
<p>Rust 编译器可以使用借用检查器来验证借用是否有效。 借用检查器会在编译时比较两个生存期。 在此场景中，<code>x</code> 的生存期为 <code>&#39;a</code>，但它引用了生存期为 <code>&#39;b</code> 的值。 引用主体（生存期为 <code>&#39;b</code> 的 y）的生存期比引用（生存期为 <code>&#39;a</code> 的 <code>x</code>）的生存期短，因此程序不会进行编译</p>
<p>另一个例子：</p>
<pre class="line-numbers language-Rust" data-language="Rust"><code class="language-Rust">fn main() &#123;
    let magic1 &#x3D; String::from(&quot;abracadabra!&quot;);
    let result;
    &#123;
        let magic2 &#x3D; String::from(&quot;shazam!&quot;);
        result &#x3D; longest_word(&amp;magic1, &amp;magic2);
    &#125;
    println!(&quot;The longest magic word is &#123;&#125;&quot;, result);
&#125;

fn longest_word&lt;&#39;a&gt;(x: &amp;&#39;a String, y: &amp;&#39;a String) -&gt; &amp;&#39;a String &#123;
    if x.len() &gt; y.len() &#123;
        x
    &#125; else &#123;
        y
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>错误:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">error<span class="token punctuation">[</span>E0597<span class="token punctuation">]</span>: <span class="token variable"><span class="token variable">`</span>magic2<span class="token variable">`</span></span> does not live long enough
     --<span class="token operator">></span> src/main.rs:6:40
      <span class="token operator">|</span>
    <span class="token number">6</span> <span class="token operator">|</span>         result <span class="token operator">=</span> longest_word<span class="token punctuation">(</span><span class="token operator">&amp;</span>magic1, <span class="token operator">&amp;</span>magic2<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token operator">|</span>                                        ^^^^^^^ borrowed value does not live long enough
    <span class="token number">7</span> <span class="token operator">|</span>     <span class="token punctuation">&#125;</span>
      <span class="token operator">|</span>     - <span class="token variable"><span class="token variable">`</span>magic2<span class="token variable">`</span></span> dropped here <span class="token keyword">while</span> still borrowed
    <span class="token number">8</span> <span class="token operator">|</span>     println<span class="token operator">!</span><span class="token punctuation">(</span><span class="token string">"The longest magic word is &#123;&#125;"</span>, result<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token operator">|</span>                                              ------ borrow later used here<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>此错误表明编译器预期 <code>magic2</code> 的生存期与返回值和 <code>x</code> 输入参数的生存期相同。 Rust 预料会出现这种行为，因为我们使用同一生存期名称 (<code>&#39;a</code>) 对函数参数和返回值的生存期进行了批注</p>
<p>如果我们检查代码，作为人类，我们会看到 <code>magic1</code> 比 <code>magic2</code> 长。 我们会看到，结果包含对 <code>magic1</code> 的引用，该引用的生存期足够长，因此有效。 但是，Rust 在编译时无法运行该代码。 它会将 <code>&amp;magic1</code> 和 <code>&amp;magic2</code> 引用都视为可能的返回值，并会发出我们此前看到的错误</p>
<p><code>longest_word</code> 函数返回的引用生存期与传入的引用生存期中较小者相匹配。 因此，代码可能包含无效引用，借用检查器将禁止该引用</p>
<h2 id="Trait"><a href="#Trait" class="headerlink" title="Trait"></a>Trait</h2><pre class="line-numbers language-Rust" data-language="Rust"><code class="language-Rust">trait Area &#123;
    fn area(&amp;self) -&gt; f64;
&#125;

struct Circle &#123;
    radius: f64,
&#125;

struct Rectangle &#123;
    width: f64,
    height: f64,
&#125;

impl Area for Circle &#123;
    fn area(&amp;self) -&gt; f64 &#123;
        use std::f64::consts::PI;
        PI * self.radius.powf(2.0)
    &#125;
&#125;

impl Area for Rectangle &#123;
    fn area(&amp;self) -&gt; f64 &#123;
        self.width * self.height
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>为实现某种类型的特征，使用关键字<code>impl Trait for Type</code>，其中<code>Trait</code> 是要实现的特征的名称，<code>Type</code> 是实现器结构体或枚举的名称</p>
<p>在<code>impl</code> 块中，放置特征所需的方法签名，并使用自己希望特征的方法对于特定类型具有的特定行为填充方法主体</p>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><pre class="line-numbers language-Rust" data-language="Rust"><code class="language-Rust">trait Iterator &#123;
    type Item;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>Iterator</code> 具有方法<code>next</code>，调用时它将返回<code>Option&lt;Item&gt;</code>。只要有元素，<code>next</code> 方法就会返回<code>Some(Item)</code>。用尽所有元素后，它将会返回<code>None</code> 以指示迭代已完成</p>
<p><code>type Item</code> 和 <code>Self::Item</code>，它们使用此特征定义关联的类型。此定义意味着<code>Iterator</code> 特征的每一次实现还需要定义关联的<code>Item</code> 类型，该类型用作<code>next</code> 方法的返回类型。换句话说，<code>Item</code> 类型将是从<code>for</code> 循环块内的迭代器返回的类型</p>
<h2 id="模块、包和第三方crate"><a href="#模块、包和第三方crate" class="headerlink" title="模块、包和第三方crate"></a>模块、包和第三方crate</h2><h3 id="理解代码组织背后的概念"><a href="#理解代码组织背后的概念" class="headerlink" title="理解代码组织背后的概念"></a>理解代码组织背后的概念</h3><ul>
<li>包<ul>
<li>包含一个或多个crete内的功能</li>
<li>包括有关如何生成这些crate的信息。该信息位于<code>Cargo.toml</code> 文件中</li>
</ul>
</li>
<li>箱<ul>
<li>是编译单元，即 Rust 编译器可以运行的最小码量</li>
<li>编译完成后，系统将生成可执行文件或库文件</li>
<li>其中包含未命名的隐式顶层模块</li>
</ul>
</li>
<li>模块<ul>
<li>是箱内的代码组织单位（或为嵌套形式）</li>
<li>可以具有跨其他模块的递归定义</li>
</ul>
</li>
</ul>
<h3 id="程序包"><a href="#程序包" class="headerlink" title="程序包"></a>程序包</h3><p>每当运行<code>Cargo new &lt;project-name&gt;</code> 命令时，Cargo将会为我们创建一个包</p>
<h3 id="板条箱"><a href="#板条箱" class="headerlink" title="板条箱"></a>板条箱</h3><p>Rust 的编译模型集中在名为箱 的项目中，可以将这些项目译为二进制文件或库文件</p>
<p>使用<code>cargo new</code> 命令创建的每个项目本身都是箱。可以在项目中用作依赖项的所有第三方Rust 代码也是单个箱</p>
<h3 id="库文件箱"><a href="#库文件箱" class="headerlink" title="库文件箱"></a>库文件箱</h3><p>创建库命令<code>cargo new --lib</code></p>
<h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>Rust 具有功能强大的模块系统。该系统可以分层方式将代码拆分为逻辑单元，从而提高其可读性和重用性</p>
<p>模块是项的集合：</p>
<ul>
<li>常量</li>
<li>类型别名</li>
<li>函数</li>
<li>结构</li>
<li>枚举</li>
<li>trait</li>
<li><code>impl</code> 块</li>
<li>其他模块</li>
</ul>
<p>模块还控制项隐私。项隐私将项标识为 public 和 private。public 表示项可以由外部代码使用。private 表示该项是内部实现详细信息，不能供外部使用</p>
<pre class="line-numbers language-Rust" data-language="Rust"><code class="language-Rust">mod math &#123;
    type Complex &#x3D; (f64, f64);
    pub fn sin(f: f64) -&gt; f64 &#123; &#x2F;* ... *&#x2F; &#125;
    pub fn cos(f: f64) -&gt; f64 &#123; &#x2F;* ... *&#x2F; &#125;
    pub fn tan(f: f64) -&gt; f64 &#123; &#x2F;* ... *&#x2F; &#125;
&#125;

println!(&quot;&#123;&#125;&quot;, math::cos(45.0));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果源文件中存在<code>mod</code> 声明，则在运行编译器之前，系统会将模块文件的内容插入到<code>mod</code> 声明的源文件中的所在位置。换句话说，系统不会对模块进行单独编译，只会编译箱</p>
<p>Rust 编译器会检查以确定是否可以跨模块使用项。默认情况下，Rust 中的所有内容都是专用的，并且只能由当前模块及其后代访问。与此相反，当项被声明<code>pub</code> 时，则可以将其视为可供外界访问</p>
<pre class="line-numbers language-Rust" data-language="Rust"><code class="language-Rust">&#x2F;&#x2F; Declare a private struct
struct Foo;

&#x2F;&#x2F; Declare a public struct with a private field
pub struct Bar &#123;
    field: i32,
&#125;

&#x2F;&#x2F; Declare a public enum with two public variants
pub enum State &#123;
    PubliclyAccessibleVariant,
    PubliclyAccessibleVariant2,
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="向项目中添加第三方箱"><a href="#向项目中添加第三方箱" class="headerlink" title="向项目中添加第三方箱"></a>向项目中添加第三方箱</h3><pre class="line-numbers language-toml" data-language="toml"><code class="language-toml"><span class="token punctuation">[</span><span class="token table class-name">dependencies</span><span class="token punctuation">]</span>
<span class="token key property">regex</span> <span class="token punctuation">=</span> <span class="token string">"1.4.2"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>如果在<code>Cargo.toml</code> 没有<code>[dependencies]</code> 部分，手动添加该部分即可</p>
<h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><p>Rust中的单元测试是用<code>#[test]</code> 属性标记的简单函数，可用于验证非测试代码是否按照预期方式正常运行。系统仅会在测试代码时编译这些函数</p>
<p>测试函数会运行要测试的代码。然后，这些函数通常使用<code>assert!</code> 或<code>assert_eq!</code> 宏来检查结果</p>
<pre class="line-numbers language-Rust" data-language="Rust"><code class="language-Rust">fn add(a: i32, b: i32) -&gt; i32 &#123;
    a + b
&#125;

#[test]
fn add_works() &#123;
    assert_eq!(add(1, 2), 3);
    assert_eq!(add(10, 12), 22);
    assert_eq!(add(5, -2), 3);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="预期的失败"><a href="#预期的失败" class="headerlink" title="预期的失败"></a>预期的失败</h3><p>使用<code>should_panic</code>，便可以检查<code>panic!</code>。如果将此属性添加到测试函数，则当函数中的代码崩溃时，测试便会通过。当代码不崩溃时，测试便会失败</p>
<pre class="line-numbers language-Rust" data-language="Rust"><code class="language-Rust">#[test]
#[should_panic]
fn add_fails() &#123;
    assert_eq!(add(2, 2), 7);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="忽略测试"><a href="#忽略测试" class="headerlink" title="忽略测试"></a>忽略测试</h3><p>可以使用<code>#[ignore]</code> 属性对带有<code>#[test]</code> 属性批注的函数进行批注。此属性会令系统在测试过程中跳过该测试函数</p>
<pre class="line-numbers language-Rust" data-language="Rust"><code class="language-Rust">#[test]
#[ignore &#x3D; &quot;not yet reviewed by the Q.A. team&quot;]
fn add_negatives() &#123;
    assert_eq!(add(-2, -2), -4)
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="测试模块"><a href="#测试模块" class="headerlink" title="测试模块"></a>测试模块</h3><p>大多数单元测试将进入带有<code>#[cfg(test)]</code> 属性的字模块</p>
<pre class="line-numbers language-Rust" data-language="Rust"><code class="language-Rust">fn add(a: i32, b: i32) -&gt; i32 &#123;
    a + b
&#125;

#[cfg(test)]
mod add_function_tests &#123;
    use super::*;

    #[test]
    fn add_works() &#123;
        assert_eq!(add(1, 2), 3);
        assert_eq!(add(10, 12), 22);
        assert_eq!(add(5, -2), 3);
    &#125;

    #[test]
    #[should_panic]
    fn add_fails() &#123;
        assert_eq!(add(2, 2), 7);
    &#125;

    #[test]
    #[ignore]
    fn add_negatives() &#123;
        assert_eq!(add(-2, -2), -4)
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>cfg</code> 属性负责控制条件编译，并仅会在谓词为<code>true</code> 时编译其所附带的内容。每当执行<code>cargo test</code> 命令时，Cargo都会自动发出<code>test</code> 编译标志，因此，当我们运行测试时，该标志将会始终为<code>true</code></p>
<p><code>use super::*;</code> 声明是<code>add_function_tests</code> 模块内部代码访问外部模块中<code>add</code> 的必要条件</p>
<h3 id="写入文档测试"><a href="#写入文档测试" class="headerlink" title="写入文档测试"></a>写入文档测试</h3><p>通过Rust，可以将文档示例作为测试来执行。记录Rust库的主要方式是使用三斜杠<code>///</code> 注释源代码，即熟知的文档注释。文档注释会写入到Markdown中，并支持其中的代码块，因此可以对这些代码块进行编译并将其用作测试</p>
<p>若要尝试此功能，需要先创建一个新的库项目</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cargo</span> new <span class="token parameter variable">--lib</span> r20-test-doc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-Rust" data-language="Rust"><code class="language-Rust">&#x2F;&#x2F;&#x2F; Generally, the first line is a brief summary describing the function.
&#x2F;&#x2F;&#x2F;
&#x2F;&#x2F;&#x2F; The next lines present detailed documentation. 
&#x2F;&#x2F;&#x2F; Code blocks start with triple backticks. The code has an implicit &#96;fn main()&#96; inside and &#96;extern crate &lt;cratename&gt;&#96;,  
&#x2F;&#x2F;&#x2F; which means you can just start writing code.
&#x2F;&#x2F;&#x2F;
&#x2F;&#x2F;&#x2F; &#96;&#96;&#96;
&#x2F;&#x2F;&#x2F; let result &#x3D; basic_math::add(2, 3);
&#x2F;&#x2F;&#x2F; assert_eq!(result, 5);
&#x2F;&#x2F;&#x2F; &#96;&#96;&#96;
pub fn add(a: i32, b: i32) -&gt; i32 &#123;
    a + b
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>与单元测试一样，如果文档测试未在运行时崩溃，则表示其顺利通过。若要验证某些结果，使用<code>aeert!</code> 宏来验证实际输出是否与预期相同。可以通过命令<code>cargo test</code> 调用此代码的测试套件</p>
<h3 id="写入集成测试"><a href="#写入集成测试" class="headerlink" title="写入集成测试"></a>写入集成测试</h3><p>单元和文档测试提供了简洁具体的测试。 但是，将 Crate 作为一个整体测试也是一种好办法。 然后，我们可以确认 Crate 的各代码部分是否按预期一起运行</p>
<p>若要将 Crate 作为成体进行测试，可以使用集成测试。 Rust 测试套件支持这种类型的测试，该测试仅调用库的公共 API 包含的函数。 我们可以使用集成测试来检查代码在其他人员使用它时的工作情况</p>
<p>这些测试的独特之处在于它们存在于单独的目录和文件中，因此它们可以在外部对库代码进行测试。 使用 Cargo 运行集成测试时，请将测试放在“tests”目录中。 Cargo 会运行此目录中的每个源文件。 在项目目录中创建测试，级别与你的 src 目录相同</p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><h3 id="三种Fn-特征"><a href="#三种Fn-特征" class="headerlink" title="三种Fn 特征"></a>三种<code>Fn</code> 特征</h3><ul>
<li><p><code>FnOnce</code>,该类型的闭包会拿走被捕获变量的所有权</p>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">fn_once</span><span class="token operator">&lt;</span><span class="token class-name">F</span><span class="token operator">></span><span class="token punctuation">(</span>func<span class="token punctuation">:</span> <span class="token class-name">F</span><span class="token punctuation">)</span> 
<span class="token keyword">where</span>
    <span class="token class-name">F</span><span class="token punctuation">:</span> <span class="token class-name">FnOnce</span><span class="token punctuation">(</span><span class="token keyword">usize</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token keyword">bool</span> <span class="token operator">+</span> <span class="token class-name">Copy</span><span class="token punctuation">,</span>
<span class="token punctuation">&#123;</span>
    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"&#123;func(3)&#125;"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"&#123;func(4)&#125;"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token macro property">vec!</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token function">fn_once</span><span class="token punctuation">(</span><span class="token closure-params"><span class="token closure-punctuation punctuation">|</span>z<span class="token closure-punctuation punctuation">|</span></span> <span class="token punctuation">&#123;</span>z <span class="token operator">==</span> x<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果想强制闭包取得捕获变量的所有权,可以在参数列表前添加<code>move</code>关键字,这种用法通常用于闭包的生命周期大于捕获变量的生命周期,例如将闭包返回或移入其他线程</p>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">use</span> <span class="token namespace">std<span class="token punctuation">::</span></span>thread<span class="token punctuation">;</span>

<span class="token keyword">let</span> v <span class="token operator">=</span> <span class="token macro property">vec!</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> handle <span class="token operator">=</span> <span class="token namespace">thread<span class="token punctuation">::</span></span><span class="token function">spawn</span><span class="token punctuation">(</span><span class="token keyword">move</span> <span class="token closure-params"><span class="token closure-punctuation punctuation">|</span><span class="token closure-punctuation punctuation">|</span></span> <span class="token punctuation">&#123;</span>
    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Here's a vector: &#123;:?&#125;"</span><span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
handle<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><code>FnMut</code>,它以可变借用的方式捕获了环境中的值,因此可以修改该值</p>
</li>
</ul>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">fn_mut</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">let</span> <span class="token keyword">mut</span> s <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// mut,update_string可变闭包</span>
    <span class="token keyword">let</span> <span class="token keyword">mut</span> update_string <span class="token operator">=</span> <span class="token closure-params"><span class="token closure-punctuation punctuation">|</span><span class="token keyword">str</span><span class="token closure-punctuation punctuation">|</span></span> s<span class="token punctuation">.</span><span class="token function">push_str</span><span class="token punctuation">(</span><span class="token keyword">str</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">update_string</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"&#123;:?&#125;"</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">fn_mut1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">let</span> <span class="token keyword">mut</span> s <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> update_string <span class="token operator">=</span> <span class="token closure-params"><span class="token closure-punctuation punctuation">|</span><span class="token keyword">str</span><span class="token closure-punctuation punctuation">|</span></span> s<span class="token punctuation">.</span><span class="token function">push_str</span><span class="token punctuation">(</span><span class="token keyword">str</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 编译器会自动推导出update_string闭包的类型</span>
    <span class="token function">exec</span><span class="token punctuation">(</span>update_string<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"&#123;:?&#125;"</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">fn</span> <span class="token function-definition function">exec</span><span class="token operator">&lt;</span><span class="token lifetime-annotation symbol">'a</span><span class="token punctuation">,</span> <span class="token class-name">F</span><span class="token punctuation">:</span> <span class="token class-name">FnMut</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token lifetime-annotation symbol">'a</span> <span class="token keyword">str</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">mut</span> f<span class="token punctuation">:</span> <span class="token class-name">F</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token function">f</span><span class="token punctuation">(</span><span class="token string">"world"</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><code>Fn</code>特征,它以不可变借用的方式捕获环境中的值</li>
</ul>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">fn_1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">let</span> update_string <span class="token operator">=</span> <span class="token closure-params"><span class="token closure-punctuation punctuation">|</span>chs<span class="token closure-punctuation punctuation">|</span></span> <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"&#123;&#125; &#123;&#125;"</span><span class="token punctuation">,</span> s<span class="token punctuation">,</span> chs<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">exec1</span><span class="token punctuation">(</span>update_string<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">fn</span> <span class="token function-definition function">exec1</span><span class="token operator">&lt;</span><span class="token class-name">F</span><span class="token punctuation">:</span> <span class="token class-name">Fn</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token punctuation">(</span>f<span class="token punctuation">:</span> <span class="token class-name">F</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token function">f</span><span class="token punctuation">(</span><span class="token string">"world"</span><span class="token punctuation">.</span><span class="token function">to_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="move和Fn"><a href="#move和Fn" class="headerlink" title="move和Fn"></a><code>move</code>和<code>Fn</code></h3><p>在上面,我们讲到了<code>move</code>关键字对于<code>FnOnce</code>特征的重要性,但实际上使用了<code>move</code>的闭包依然可能实现了<code>Fn</code>或<code>FnMut</code>特征</p>
<p>因此,一个闭包实现了哪种Fn特征取决于该闭包如何使用被捕获的变量,而不是取决于闭包如何捕获它们.move本身强调的就是后者,闭包如何捕获变量:</p>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">let</span> update_string <span class="token operator">=</span>  <span class="token keyword">move</span> <span class="token closure-params"><span class="token closure-punctuation punctuation">|</span><span class="token closure-punctuation punctuation">|</span></span> <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"&#123;&#125;"</span><span class="token punctuation">,</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">exec</span><span class="token punctuation">(</span>update_string<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">fn</span> <span class="token function-definition function">exec</span><span class="token operator">&lt;</span><span class="token class-name">F</span><span class="token punctuation">:</span> <span class="token class-name">FnOnce</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token punctuation">(</span>f<span class="token punctuation">:</span> <span class="token class-name">F</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>
    <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这个闭包中使用了move关键字,所以我们的闭包捕获了它,但是由于闭包对s的使用仅仅是不可变借用,因此该闭包实际上还实现了Fn特征.因为该闭包不仅仅实现了FnOnce特征</p>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">let</span> update_string <span class="token operator">=</span>  <span class="token keyword">move</span> <span class="token closure-params"><span class="token closure-punctuation punctuation">|</span><span class="token closure-punctuation punctuation">|</span></span> <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"&#123;&#125;"</span><span class="token punctuation">,</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">exec</span><span class="token punctuation">(</span>update_string<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">fn</span> <span class="token function-definition function">exec</span><span class="token operator">&lt;</span><span class="token class-name">F</span><span class="token punctuation">:</span> <span class="token class-name">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token punctuation">(</span>f<span class="token punctuation">:</span> <span class="token class-name">F</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>
    <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="三种Fn的关系"><a href="#三种Fn的关系" class="headerlink" title="三种Fn的关系"></a>三种Fn的关系</h3><p>实际上,一个闭包并不仅仅实现某一种Fn特征,规则如下:</p>
<ul>
<li>所有的闭包都自动实现了FnOnce特征,因此任何一个闭包都至少可以被调用一次</li>
<li>没有移出所捕获变量的所有权的闭包自动实现了FnMut特征</li>
<li>不需要对捕获变量进行改变的闭包自动实现了Fn特征</li>
</ul>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">fn_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"Hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">let</span> update_string <span class="token operator">=</span> <span class="token closure-params"><span class="token closure-punctuation punctuation">|</span><span class="token closure-punctuation punctuation">|</span></span> <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"&#123;&#125;"</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">exec_fn</span><span class="token punctuation">(</span>update_string<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">exec_fn_once</span><span class="token punctuation">(</span>update_string<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">exec_fn_mut</span><span class="token punctuation">(</span>update_string<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">fn</span> <span class="token function-definition function">exec_fn_once</span><span class="token operator">&lt;</span><span class="token class-name">F</span><span class="token punctuation">:</span> <span class="token class-name">FnOnce</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token punctuation">(</span>f<span class="token punctuation">:</span> <span class="token class-name">F</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">fn</span> <span class="token function-definition function">exec_fn_mut</span><span class="token operator">&lt;</span><span class="token class-name">F</span><span class="token punctuation">:</span> <span class="token class-name">FnMut</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">mut</span> f<span class="token punctuation">:</span> <span class="token class-name">F</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">fn</span> <span class="token function-definition function">exec_fn</span><span class="token operator">&lt;</span><span class="token class-name">F</span><span class="token punctuation">:</span> <span class="token class-name">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token punctuation">(</span>f<span class="token punctuation">:</span> <span class="token class-name">F</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="闭包作为函数返回值"><a href="#闭包作为函数返回值" class="headerlink" title="闭包作为函数返回值"></a>闭包作为函数返回值</h3><p>需要加上<code>impl</code>,或者使用智能指针(如Box)包裹返回</p>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token comment">// 编译报错</span>
<span class="token keyword">fn</span> <span class="token function-definition function">factory</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span><span class="token keyword">i32</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token keyword">impl</span> <span class="token class-name">Fn</span><span class="token punctuation">(</span><span class="token keyword">i32</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token keyword">i32</span> <span class="token punctuation">&#123;</span>

    <span class="token keyword">let</span> num <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> x <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">&#123;</span>
        <span class="token keyword">move</span> <span class="token closure-params"><span class="token closure-punctuation punctuation">|</span>x<span class="token closure-punctuation punctuation">|</span></span> x <span class="token operator">+</span> num
    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">move</span> <span class="token closure-params"><span class="token closure-punctuation punctuation">|</span>x<span class="token closure-punctuation punctuation">|</span></span> x <span class="token operator">-</span> num
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 改正</span>
<span class="token keyword">fn</span> <span class="token function-definition function">factory</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span><span class="token keyword">i32</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token class-name">Box</span><span class="token operator">&lt;</span><span class="token keyword">dyn</span> <span class="token class-name">Fn</span><span class="token punctuation">(</span><span class="token keyword">i32</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token keyword">i32</span><span class="token operator">></span> <span class="token punctuation">&#123;</span>

    <span class="token keyword">let</span> num <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> x <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">&#123;</span>
        <span class="token keyword">move</span> <span class="token closure-params"><span class="token closure-punctuation punctuation">|</span>x<span class="token closure-punctuation punctuation">|</span></span> x <span class="token operator">+</span> num
    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">move</span> <span class="token closure-params"><span class="token closure-punctuation punctuation">|</span>x<span class="token closure-punctuation punctuation">|</span></span> x <span class="token operator">-</span> num
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="迭代器-1"><a href="#迭代器-1" class="headerlink" title="迭代器"></a>迭代器</h2><h3 id="Iterator-和-IntoIterator的区别"><a href="#Iterator-和-IntoIterator的区别" class="headerlink" title="Iterator 和 IntoIterator的区别"></a>Iterator 和 IntoIterator的区别</h3><p>这两个其实很容易搞混.</p>
<p><code>Iterator</code>就是迭代器特征,只有实现了它才能成为迭代器,才能调用<code>next</code></p>
<p><code>IntoIterator</code>强调的是某一个类型如果实现了该特征,它可以通过<code>into_iter</code>, <code>iter</code>等方法变成一个迭代器</p>
<h3 id="消费者与适配器"><a href="#消费者与适配器" class="headerlink" title="消费者与适配器"></a>消费者与适配器</h3><p>消费者是迭代器上的方法,它会消费掉迭代器中的元素,然后返回其类型的值,这些消费者都是有一个共同的特点:在它们的定义中,都依赖<code>next</code>方法来消费元素,因此这也是为什么迭代器要实现<code>Iterator</code>特征,而该特征必须要实现<code>next</code>方法的原因</p>
<p><code>消费者适配器</code></p>
<p>只要迭代器上的某个方法A在其内部调用了<code>next</code>方法,那么A就被称为<code>消费性适配器</code>:因为<code>next</code>方法会消耗掉迭代器上的元素,所以方法A的调用也会消耗掉迭代器上的元素</p>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">let</span> v1 <span class="token operator">=</span> <span class="token macro property">vec!</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token keyword">let</span> v1_iter <span class="token operator">=</span> v1<span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">let</span> total<span class="token punctuation">:</span> <span class="token keyword">i32</span> <span class="token operator">=</span> v1_iter<span class="token punctuation">.</span><span class="token function">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token macro property">assert_eq!</span><span class="token punctuation">(</span>total<span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// v1_iter 是借用了 v1，因此 v1 可以照常使用</span>
    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"&#123;:?&#125;"</span><span class="token punctuation">,</span>v1<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 以下代码会报错，因为 `sum` 拿到了迭代器 `v1_iter` 的所有权</span>
    <span class="token comment">// println!("&#123;:?&#125;",v1_iter);</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如代码注释中所说明的:在使用<code>sum</code>方法后,我们将无法再使用<code>v1_iter</code>,因为<code>sum</code>拿走了该迭代器的所有权:</p>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">sum</span><span class="token operator">&lt;</span><span class="token class-name">S</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token class-name">S</span> 
<span class="token keyword">where</span>
    <span class="token keyword">Self</span><span class="token punctuation">:</span> <span class="token class-name">Sized</span><span class="token punctuation">,</span>
    <span class="token class-name">S</span><span class="token punctuation">:</span> <span class="token class-name">Sum</span><span class="token operator">&lt;</span><span class="token keyword">Self</span><span class="token punctuation">::</span><span class="token class-name">Item</span><span class="token operator">></span><span class="token punctuation">,</span>
<span class="token punctuation">&#123;</span>
    <span class="token class-name">Sum</span><span class="token punctuation">::</span><span class="token function">sum</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>迭代器适配器</code></p>
<p>既然消费者适配器是消费掉迭代器,然后返回一个值.那么迭代器适配器,顾名思义,会返回一个新的迭代器,这是实现链式方式方法调用的关键: <code>v.iter().map().filter()...</code></p>
<p>与消费者适配器不同,迭代器适配器是惰性的,意味着需要一个消费者适配器来收尾,最终将迭代器转换成一个具体的值:</p>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">let</span> v1 <span class="token operator">=</span> <span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token keyword">u32</span><span class="token operator">></span> <span class="token operator">=</span> <span class="token macro property">vec!</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
v1<span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token closure-params"><span class="token closure-punctuation punctuation">|</span>x<span class="token closure-punctuation punctuation">|</span></span> x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 编译报错</span>
warning<span class="token punctuation">:</span> unused `<span class="token class-name">Map</span>` that must be used
 <span class="token operator">-</span><span class="token punctuation">-></span> src<span class="token operator">/</span>main<span class="token punctuation">.</span>rs<span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token number">5</span>
  <span class="token operator">|</span>
<span class="token number">4</span> <span class="token operator">|</span>     v1<span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token closure-params"><span class="token closure-punctuation punctuation">|</span>x<span class="token closure-punctuation punctuation">|</span></span> x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token operator">|</span>     <span class="token operator">^</span><span class="token operator">^</span><span class="token operator">^</span><span class="token operator">^</span><span class="token operator">^</span><span class="token operator">^</span><span class="token operator">^</span><span class="token operator">^</span><span class="token operator">^</span><span class="token operator">^</span><span class="token operator">^</span><span class="token operator">^</span><span class="token operator">^</span><span class="token operator">^</span><span class="token operator">^</span><span class="token operator">^</span><span class="token operator">^</span><span class="token operator">^</span><span class="token operator">^</span><span class="token operator">^</span><span class="token operator">^</span><span class="token operator">^</span><span class="token operator">^</span><span class="token operator">^</span><span class="token operator">^</span>
  <span class="token operator">|</span>
  <span class="token operator">=</span> note<span class="token punctuation">:</span> `<span class="token attribute attr-name">#[warn(unused_must_use)]</span>` on by default
  <span class="token operator">=</span> note<span class="token punctuation">:</span> iterators are lazy and <span class="token keyword">do</span> nothing unless consumed <span class="token comment">// 迭代器 map 是惰性的，这里不产生任何效果</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里的<code>map</code>方法是一个迭代器适配器,它是惰性的,不产生任何行为,因此我们还需要一个消费者适配器进行收尾:</p>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">let</span> v1<span class="token punctuation">:</span> <span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token keyword">i32</span><span class="token operator">></span> <span class="token operator">=</span> <span class="token macro property">vec!</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> v2<span class="token punctuation">:</span> <span class="token class-name">Vec</span><span class="token operator">&lt;</span>_<span class="token operator">></span> <span class="token operator">=</span> v1<span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token closure-params"><span class="token closure-punctuation punctuation">|</span>x<span class="token closure-punctuation punctuation">|</span></span> x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token macro property">assert_eq!</span><span class="token punctuation">(</span>v2<span class="token punctuation">,</span> <span class="token macro property">vec!</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>collect</code></p>
<p>上面代码中, 使用了<code>collect</code>方法,该方法就是一个消费者适配器, 使用它可以将一个迭代器中的元素收集到指定类型中, 这里我们为v2标注了<code>Vec&lt;_&gt;</code>类型,就是为了告诉<code>collect</code>: 请把迭代器中的元素消费掉, 然后把值收集成<code>Vec&lt;_&gt;</code>类型, 至于为何使用<code>_</code>, 因为编译器会帮我们自动推导</p>
<h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><p><code>堆栈</code></p>
<p>栈内存从高位地址向下增长，且栈内存是连续分配的</p>
<p>在 Rust 中，main 线程的栈大小是 8MB，普通线程是 2MB，在函数调用时会在其中创建一个临时栈空间，调用结束后 Rust 会让这个栈空间里的对象自动进入 Drop 流程，最后栈顶指针自动移动到上一个调用栈顶，无需程序员手动干预，因而栈内存申请和释放是非常高效的</p>
<p>与栈相反，堆上内存则是从低位地址向上增长，堆内存通常只受物理内存限制，而且通常是不连续的，因此从性能的角度看，栈往往比堆更高</p>
<p>相比其它语言，Rust 堆上对象还有一个特殊之处，它们都拥有一个所有者，因此受所有权规则的限制：当赋值时，发生的是所有权的转移（只需浅拷贝栈上的引用或智能指针即可），例如以下代码：</p>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token string">"world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"&#123;&#125;"</span><span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">fn</span> <span class="token function-definition function">foo</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">str</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token class-name">String</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token string">"Hello, "</span><span class="token punctuation">.</span><span class="token function">to_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> x<span class="token punctuation">;</span>
    a
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="堆栈的性能"><a href="#堆栈的性能" class="headerlink" title="堆栈的性能"></a>堆栈的性能</h3><p>很多人可能会觉得栈的性能肯定比堆高，其实未必。 由于我们在后面的性能专题会专门讲解堆栈的性能问题，因此这里就大概给出结论：</p>
<ul>
<li>小型数据，在栈上的分配性能和读取性能都要比堆上高</li>
<li>中型数据，栈上分配性能高，但是读取性能和堆上并无区别，因为无法利用寄存器或 CPU 高速缓存，最终还是要经过一次内存寻址</li>
<li>大型数据，只建议在堆上分配和使用</li>
</ul>
<h3 id="Box-的使用场景"><a href="#Box-的使用场景" class="headerlink" title="Box 的使用场景"></a>Box 的使用场景</h3><p>由于 Box 是简单的封装，除了将值存储在堆上外，并没有其它性能上的损耗。而性能和功能往往是鱼和熊掌，因此 Box 相比其它智能指针，功能较为单一，可以在以下场景中使用它：</p>
<ul>
<li>特意的将数据分配在堆上</li>
<li>数据较大时，又不想在转移所有权时进行数据拷贝</li>
<li>类型的大小在编译期无法确定，但是我们又需要固定大小的类型时</li>
<li>特征对象，用于说明对象实现了一个特征，而不是某个特定的类型</li>
</ul>
<h2 id="Drop"><a href="#Drop" class="headerlink" title="Drop"></a>Drop</h2><p><code>互斥的Copy和Drop</code></p>
<p>我们无法为一个类型同时实现<code>Copy</code> 和<code>Drop</code> 特征. 因为实现了<code>Copy</code> 的特征会被编译器隐式的复制, 因此非常难以预测析构函数执行的时间和频率. 因此这些实现了<code>Copy</code> 的类型无法拥有析构函数</p>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token attribute attr-name">#[derice(Debug)]</span>
<span class="token keyword">struct</span> <span class="token type-definition class-name">Foo</span><span class="token punctuation">;</span>

<span class="token keyword">impl</span> <span class="token class-name">Drop</span> <span class="token keyword">for</span> <span class="token class-name">Foo</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">fn</span> <span class="token function-definition function">drop</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"Deopping Foo!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>以上代码报错如下:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">error<span class="token punctuation">[</span>E0184<span class="token punctuation">]</span>: the trait <span class="token variable"><span class="token variable">`</span>Copy<span class="token variable">`</span></span> may not be implemented <span class="token keyword">for</span> this <span class="token builtin class-name">type</span><span class="token punctuation">;</span> the <span class="token builtin class-name">type</span> has a destructor
  --<span class="token operator">></span> src/main.rs:24:10
   <span class="token operator">|</span>
<span class="token number">24</span> <span class="token operator">|</span> <span class="token comment">#[derive(Copy)]</span>
   <span class="token operator">|</span>          ^^^^ Copy not allowed on types with destructors<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
	  <div class="article-footer-copyright">

    本博客采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议(CC BY-NC-SA 4.0) 发布.</a>
</div>

	</div>

	
	<span id="/2023/08/24/Rust%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="leancloud-visitors view" data-flag-title="Rust学习笔记">
		<em class="post-meta-item-text"> Page View </em> <i class="leancloud-visitors-count"></i>
	</span>
	
	
	<div>
  	<center>

	<div class="pagination">

    
    
    <a href="/2023/09/04/Tokio随记/" type="button" class="btn btn-default"><i
                class="fa fa-arrow-circle-o-left"></i> 上一页</a>
    

    <a href="/" type="button" class="btn btn-default"><i class="fa fa-home"></i>Home</a>
    
    <a href="/2023/08/16/UE5随记/" type="button" class="btn btn-default ">下一页<i
                class="fa fa-arrow-circle-o-right"></i></a>
    

    
</div>


    </center>
	</div>
	
	<!-- comment -->
	<!--
<section id="comment">
    <h2 class="title">留言</h2>

    
</section>

-->
	
		<section id="comments" class="comments">
			<style>
			.comments{margin:30px;padding:10px;background:rgb(0, 0, 0)}
			@media screen and (max-width:800px){.comments{margin:auto;padding:10px;background:#000}}
			</style>
			<div id="vcomment" class="comment"></div>
<script src='//unpkg.com/valine/dist/Valine.min.js'></script>
<script src="https://cdnjs.loli.net/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
<script>
var valineConfig = {"enable":true,"appId":"uApRQOVRPXNWxGlYYBVKKly7-gzGzoHsz","appKey":"nzz9v4Vqa23OXqn68U3MYubQ","placeholder":"快！说点什么","visitor":true,"avatar":"monsterid","requiredFields":["nick","mail"],"pageView":true}
valineConfig.el='#vcomment';
new Valine(valineConfig);
    // new Valine({
    //     el: '#vcomment',
    //     appId: "",
    //     appKey: "",
    //     placeholder: "快！说点什么",
    //     avatar:"monsterid",
    //     visitor: "true",
    //     requiredFields: "nick,mail".split(','),
    // });
</script>

		</section>
	
	
	
	</div> <!-- col-md-9/col-md-12 -->


	
	<div id="side_meta">
		<div class="col-md-3" id="post_meta"> 

	<!-- date -->
	
	<div class="meta-widget">
	<i class="fa fa-clock-o"></i>
	2023-08-24 
	</div>
	

	<!-- categories -->
    
	<div class="meta-widget">
	<a data-toggle="collapse" data-target="#categorys"><i class="fa fa-folder"></i></a>	
    <ul id="categorys" class="tag_box list-unstyled collapse in">
          
  <li>
    <li><a href="/categories/笔记/">笔记<span>4</span></a></li>
  </li>

    </ul>
	</div>
	

	<!-- tags -->
	
	<div class="meta-widget">
	<a data-toggle="collapse" data-target="#tags"><i class="fa fa-tags"></i></a>		  
    <ul id="tags" class="tag_box list-unstyled collapse in">	  
	    
  <li><a href="/tags/Rust/">Rust<span>2</span></a></li>
    </ul>
	</div>
		

	<!-- toc -->
	<div class="meta-widget">
	
	   <a data-toggle="collapse" data-target="#toc"><i class="fa fa-bars"></i></a>
	   <div id="toc" class="toc collapse in">
		   <span class="toc-title">Contents</span>
			<ol class="toc-article"><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#Rust%E7%BD%91%E9%A1%B5%E7%89%88ide"><span class="toc-article-text">Rust网页版ide</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE"><span class="toc-article-text">安装配置</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#RustUp%E7%9B%B8%E5%85%B3"><span class="toc-article-text">RustUp相关</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E9%85%8D%E7%BD%AE%E5%B7%A5%E5%85%B7%E9%93%BE%E5%AE%89%E8%A3%85%E4%BD%8D%E7%BD%AE"><span class="toc-article-text">配置工具链安装位置</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E9%85%8D%E7%BD%AE%E5%9B%BD%E5%86%85%E9%95%9C%E5%83%8F"><span class="toc-article-text">配置国内镜像</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E9%85%8D%E7%BD%AE-cargo-%E5%9B%BD%E5%86%85%E9%95%9C%E5%83%8F"><span class="toc-article-text">配置 cargo 国内镜像</span></a></li></ol></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#%E4%BD%BF%E7%94%A8Rust%E6%A8%A1%E5%9D%97%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E4%BB%A3%E7%A0%81"><span class="toc-article-text">使用Rust模块系统管理代码</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#%E4%BD%BF%E7%94%A8Rust%E7%AE%B1%E5%92%8C%E5%BA%93"><span class="toc-article-text">使用Rust箱和库</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#%E4%BD%BF%E7%94%A8Cargo%E5%88%9B%E5%BB%BA%E5%92%8C%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE"><span class="toc-article-text">使用Cargo创建和管理项目</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#%E7%BB%93%E6%9E%84"><span class="toc-article-text">结构</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#%E5%88%9B%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%94%A8%E6%95%B0%E7%BB%84"><span class="toc-article-text">创建和使用数组</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E5%AE%9A%E4%B9%89%E6%95%B0%E7%BB%84"><span class="toc-article-text">定义数组</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E8%AF%BB%E5%8F%96%E6%95%B0%E7%BB%84%E7%9A%84%E5%80%BC"><span class="toc-article-text">读取数组的值</span></a></li></ol></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#Vector"><span class="toc-article-text">Vector</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#if-else"><span class="toc-article-text">if else</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E5%90%88%E5%B9%B6%E5%A4%9A%E4%B8%AA%E6%B5%8B%E8%AF%95%E6%9D%A1%E4%BB%B6"><span class="toc-article-text">合并多个测试条件</span></a></li></ol></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-article-text">错误处理</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E4%BD%BF%E7%94%A8Option%E7%B1%BB%E5%9E%8B%E6%9D%A5%E5%A4%84%E7%90%86%E7%BC%BA%E5%A4%B1"><span class="toc-article-text">使用Option类型来处理缺失</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E5%A6%82%E4%BD%95%E6%89%8D%E8%83%BD%E8%AE%BF%E9%97%AE%E5%88%B0Some-data-%E5%8F%98%E4%BD%93%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%91%A2%EF%BC%9F"><span class="toc-article-text">如何才能访问到Some(data) 变体中的数据呢？</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="toc-article-text">模式匹配</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#if-let-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-article-text">if let 表达式</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E4%BD%BF%E7%94%A8unwrap-%E5%92%8Cexpect"><span class="toc-article-text">使用unwrap 和expect</span></a></li></ol></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E4%BD%BF%E7%94%A8Result-%E7%B1%BB%E5%9E%8B%E6%9D%A5%E5%A4%84%E7%90%86%E9%94%99%E8%AF%AF"><span class="toc-article-text">使用Result 类型来处理错误</span></a></li></ol></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-article-text">内存管理</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%89%80%E6%9C%89%E6%9D%83%EF%BC%9F"><span class="toc-article-text">什么是所有权？</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%95%8C%E5%AE%9A%E8%A7%84%E5%88%99"><span class="toc-article-text">作用域界定规则</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E6%89%80%E6%9C%89%E6%9D%83%E5%92%8C%E5%88%A0%E9%99%A4"><span class="toc-article-text">所有权和删除</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89"><span class="toc-article-text">移动语义</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E6%9D%83"><span class="toc-article-text">函数中的所有权</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E5%A4%8D%E5%88%B6%E8%80%8C%E4%B8%8D%E6%98%AF%E7%A7%BB%E5%8A%A8"><span class="toc-article-text">复制而不是移动</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E5%A4%8D%E5%88%B6%E4%B8%8D%E5%AE%9E%E7%8E%B0Copy-%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-article-text">复制不实现Copy 的类型</span></a></li></ol></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E4%BA%86%E8%A7%A3%E5%80%9F%E7%94%A8"><span class="toc-article-text">了解借用</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E5%BC%95%E7%94%A8"><span class="toc-article-text">函数中的引用</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E6%94%B9%E5%8F%98%E5%80%9F%E7%94%A8%E7%9A%84%E5%80%BC"><span class="toc-article-text">改变借用的值</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#%E5%80%9F%E7%94%A8%E5%92%8C%E5%8F%AF%E5%8F%98%E5%BC%95%E7%94%A8"><span class="toc-article-text">借用和可变引用</span></a></li></ol></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E4%BD%BF%E7%94%A8%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%AA%8C%E8%AF%81%E5%BC%95%E7%94%A8"><span class="toc-article-text">使用生命周期验证引用</span></a></li></ol></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#Trait"><span class="toc-article-text">Trait</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-article-text">迭代器</span></a></li></ol></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#%E6%A8%A1%E5%9D%97%E3%80%81%E5%8C%85%E5%92%8C%E7%AC%AC%E4%B8%89%E6%96%B9crate"><span class="toc-article-text">模块、包和第三方crate</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E7%90%86%E8%A7%A3%E4%BB%A3%E7%A0%81%E7%BB%84%E7%BB%87%E8%83%8C%E5%90%8E%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-article-text">理解代码组织背后的概念</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E7%A8%8B%E5%BA%8F%E5%8C%85"><span class="toc-article-text">程序包</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E6%9D%BF%E6%9D%A1%E7%AE%B1"><span class="toc-article-text">板条箱</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E5%BA%93%E6%96%87%E4%BB%B6%E7%AE%B1"><span class="toc-article-text">库文件箱</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E6%A8%A1%E5%9D%97"><span class="toc-article-text">模块</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E5%90%91%E9%A1%B9%E7%9B%AE%E4%B8%AD%E6%B7%BB%E5%8A%A0%E7%AC%AC%E4%B8%89%E6%96%B9%E7%AE%B1"><span class="toc-article-text">向项目中添加第三方箱</span></a></li></ol></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="toc-article-text">单元测试</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E9%A2%84%E6%9C%9F%E7%9A%84%E5%A4%B1%E8%B4%A5"><span class="toc-article-text">预期的失败</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E5%BF%BD%E7%95%A5%E6%B5%8B%E8%AF%95"><span class="toc-article-text">忽略测试</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E6%B5%8B%E8%AF%95%E6%A8%A1%E5%9D%97"><span class="toc-article-text">测试模块</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E5%86%99%E5%85%A5%E6%96%87%E6%A1%A3%E6%B5%8B%E8%AF%95"><span class="toc-article-text">写入文档测试</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E5%86%99%E5%85%A5%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95"><span class="toc-article-text">写入集成测试</span></a></li></ol></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#%E9%97%AD%E5%8C%85"><span class="toc-article-text">闭包</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E4%B8%89%E7%A7%8DFn-%E7%89%B9%E5%BE%81"><span class="toc-article-text">三种Fn 特征</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#move%E5%92%8CFn"><span class="toc-article-text">move和Fn</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E4%B8%89%E7%A7%8DFn%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-article-text">三种Fn的关系</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E9%97%AD%E5%8C%85%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-article-text">闭包作为函数返回值</span></a></li></ol></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8-1"><span class="toc-article-text">迭代器</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#Iterator-%E5%92%8C-IntoIterator%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-article-text">Iterator 和 IntoIterator的区别</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E6%B6%88%E8%B4%B9%E8%80%85%E4%B8%8E%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-article-text">消费者与适配器</span></a></li></ol></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-article-text">智能指针</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E5%A0%86%E6%A0%88%E7%9A%84%E6%80%A7%E8%83%BD"><span class="toc-article-text">堆栈的性能</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#Box-%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-article-text">Box 的使用场景</span></a></li></ol></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#Drop"><span class="toc-article-text">Drop</span></a></li></ol>
		</div>
	
	</div>
	
    <hr>
	
</div><!-- col-md-3 -->

		

	</div>
	
		

</div><!-- row -->

<!--
 -->



	</div>
  </div>
  <div class="container-narrow">
  <footer> <p>
  
  &copy; 2023 Arctique's Blog
  
      powered by <a href="http://hexo.io/" target="_blank">Hexo</a>.Theme <a href="https://github.com/Ares-X/hexo-theme-freemind.bithack" target="_blank">freemind.bithack</a>  
</p>
 </footer>
</div> <!-- container-narrow -->
  


  
<a id="gotop" href="#">   
  <span>⬆︎TOP</span>
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



</body>
   </html>
