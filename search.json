[{"title":"Git常用命令","url":"/2023/07/14/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","content":"Git常用命令基本使用\n首次克隆项目\ngit clone 地址 [-b 分支]\n\n\n查看分支\ngit branch\n\n\n查看工作区代码相对于暂存区的差别\ngit status\n\n\n将当前目录下修改的所有代码从工作区添加到暂存区 . 代表当前目录\ngit add .\n\n\n将缓存区内容添加到本地仓库\ngit commit  -m ‘注释’\n\n\n将本地版本库推送到远程服务器\ngit push origin 分支\n\n\n合并分支\ngit merge 分支\n\n\n查看远程仓库\ngit remote -v\n\n\n从远程仓库获取最新版本到本地仓库\ngit fetch origin master\n\n\n比较本地的仓库和远程参考的区别\ngit log -p master.. origin&#x2F;master\n\n\n把远程下载下来的代码合并到本地仓库，远程的和本地的合并\ngit merge origin&#x2F;master\n\n\n\ngit remote: HTTP Basic: Access denied\n原因：\n本地git配置的用户名、密码与gitlabs上注册的用户名、密码不一致\n\n\n解决：\n如果账号密码有变动 用这个命令 git config –system –unset credential.helper 重新输入账号密码 应该就能解决了\n如果用了第一个命令 还不能解决问题那么 用这个命令：git config –global http.emptyAuth true\n如果以上两个方法不起作用，那么采用以下方法：进入控制面板》用户账号》凭据管理器》windows凭据》普通凭据，在里面找到git，点开编辑密码，更新为最新密码之后就可以正常操作了\n\n\n\ngit更新本地代码\ngit status(查看本地分支文件信息，确保更新时不产生冲突)\n\ngit checkout - file name\n\ngit branch(查看当前分支情况)\n\ngit checkout remote branch(若分支为本地分支，则需要切换到服务器远程分支)\n\ngit pull(若命令成功，则更新代码)\n\n回退版本\n\ngit log 显示提交日志\ngit reset –hard \n\n\n\ngit生成密钥公钥ssh-keygen -t rsa -C \"your_email@youremail.com\"\n\n撤销commit-m ‘’git reset --soft HEAD^\ngit revert &lt;hashcode>\n\n修改commit注释git commit --amend\n\n撤销add# 查看当前缓存区的文件\ngit status -s\n\ngit reset HEAD\n\ngitee github代码同步\n在已有项目git中，关联github仓库，git remote add github https://github.com/cy-arctique/parent.git\n\n推送到github仓库，git push github [master]\n\n删除git默认远程仓库名称，git remote rm origin\n\n删除git关联远程仓库名称，git remote rm github\n\n\nGit中更新子模块git submodule sync\n\ngit submodule update --init --recursive\n\n只合并一个commitgit cherry-pick &lt;hashcode>\n\n本地代理sock安装代理工具\nyay -S proxychains\n\n配置 proxychains\nsudo vim /etc/proxychains.conf\n\nsocks5 127.0.0.1 7890\n\n然后再配置 clash 混合开启俩端口(7897)和 socks(7890) 端口\n使用例如：\nproxychains4 git clone git@github.com:llvm/llvm-project.git\n","categories":["笔记"],"tags":["Git"]},{"title":"Hello Hexo","url":"/2023/07/13/HelloHexo/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new \"My New Post\"\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","categories":["Hexo"],"tags":["Hexo"]},{"title":"Rust学习笔记","url":"/2023/08/24/Rust%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"Rust网页版idehttps://play.rust-lang.org/\n安装配置RustUp相关# 显示当前安装的工具链信息\nrustup show\n# 检查安装更新\nrustup update\n# 卸载\nrustup self uninstall\n# 设置当前默认工具链\nrustup default stable-x86_64-pc-windows-gnu\n# 查看帮助\nrustup -h\n\n# -------------------------->配置工具链\n# 查看工具链\nrustup toolchain list\n# 安装工具链\nrustup toolchain install stable-x86_64-pc-windows-gnu\n# 卸载工具链\nrustup toolchain uninstall stable-x86_64-pc-windows-gnu\n# 设置自定义工具链\nrustup toolchain link &lt;toolchain-name> \"&lt;toolchain-path>\"\n\n# -------------------------->配置一个目录以及其子目录的默认工具链\n# 查看已设置的默认工具链\nrustup override list\n# 设置该目录以及其子目录的默认工具链\nrustup override set &lt;toolchain> --path &lt;path>\n# 取消目录以及其子目录的默认工具链\nrustup override unset --path &lt;path>\n\n# -------------------------->配置工具链的可用目标\n# 查看目标列表\nrustup target list\n# 安装目标\nrustup target add &lt;target>\n# 卸载目标\nrustup target remove &lt;target>\n# 为特定工具链安装目标\nrustup target add --toolchain &lt;toolchain> &lt;target>\n\n# -------------------------->配置 rustup 安装的组件\n# 查看可用组件\nrustup component list\n# 安装组件\nrustup component add &lt;component>\n# 卸载组件\nrustup component remove &lt;component>\n\n配置工具链安装位置在系统环境变量中添加如下变量：\n\nCARGO_HOME - 指定cargo的安装目录\nRUSTUP_HOME - 指定rustup的安装目录\n\n默认分别安装到用户目录下的.cargo 和.rustup 目录\n配置 rustup 国内镜像在系统环境变量中添加如下变量(选一个就可以，可以组合): \n# 清华大学\nRUSTUP_DIST_SERVER：https://mirrors.tuna.tsinghua.edu.cn/rustup\nRUSTUP_UPDATE_ROOT：https://mirrors.tuna.tsinghua.edu.cn/rustup/rustup\n# 中国科学技术大学\nRUSTUP_DIST_SERVER：https://mirrors.ustc.edu.cn/rust-static\nRUSTUP_UPDATE_ROOT：https://mirrors.ustc.edu.cn/rust-static/rustup\n\n配置 cargo 国内镜像在 cargo 安装目录下新建config 文件(注意 config 没有任何后缀)，文件内容如下: \n[source.crates-io]\nregistry = \"https://github.com/rust-lang/crates.io-index\"\nreplace-with = 'tuna'\n\n# 清华大学\n[source.tuna]\nregistry = \"https://mirrors.tuna.tsinghua.edu.cn/crates.io-index\"\n\n# 中国科学技术大学\n[source.ustc]\nregistry = \"git://mirrors.ustc.edu.cn/crates.io-index\"\n# 设置代理\n# [http]\n# proxy = \"127.0.0.1:8889\"\n# [https]\n# proxy = \"127.0.0.1:8889\"\n\n使用Rust模块系统管理代码Rust 提供了一系列功能，可帮助你管理和组织代码。 这些功能称为“Rust 模块系统”。 系统由 Crate、模块、路径和工具组成，以与那些项结合使用\n\n箱：Rust 箱是一个编译单元。 它是 Rust 编译器可以运行的最小代码段。 箱中的代码一起编译以创建二进制可执行文件或库。 在 Rust 中，仅将箱编译为可重复使用的单元。 箱包含具有隐式未命名顶级模块的 Rust 模块的层次结构\n模块：Rust 模块通过让你管理箱内单个代码项的范围来帮助你组织程序。 结合使用的相关代码项或项可以分组到相同模块中。 递归代码定义可以跨越其他模块\n路径：在 Rust 中，可以使用路径来命名代码中的项。 例如，路径可以是一个数据定义（例如，矢量、代码函数，甚至是模块）。 模块功能还可帮助你控制路径的隐私。 可以指定可公开访问的代码部分和私有部分。 通过该功能可以隐藏实现详细信息\n\n使用Rust箱和库\nRust 标准库。 在 Rust 练习中，你将会注意到以下模块：\nstd::collections - 集合类型的定义，如 HashMap\nstd::env - 用于处理环境的函数\nstd::fmt - 控制输出格式的功能\nstd::fs - 用于处理文件系统的功能\nstd::io - 用于处理输入&#x2F;输出的定义和功能\nstd::path - 支持处理文件系统路径数据的定义和功能\n\n\nstructopt - 用于轻松分析命令行参数的第三方箱\nchrono - 用于处理日期和时间数据的第三方箱\nregex - 用于处理正则表达式的第三方箱\nserde - 适用于 Rust 数据结构的序列化和反序列化操作的第三方箱\n\n使用Cargo创建和管理项目\n使用 cargo new 命令创建新的项目模板\n使用 cargo build 编译项目\n使用 cargo run 命令编译并运行项目\n使用 cargo test 命令测试项目\n使用 cargo check 命令检查项目类型\n使用 cargo doc 命令编译项目的文档\n使用 cargo publish 命令将库发布到 crates.io\n通过将箱的名称添加到 Cargo.toml 文件来将依赖箱添加到项目\n\n结构Rust支持三种结构类型：经典结构、元组结构和单元结构。这些结构类型支持使用各种方式对数据进行分组和处理\n\n“经典C结构”最为常用。结构中的每个字段都具有名称和数据类型。定义经典结构后，可以使用语法.访问结构中的字段\n元组结构类似于经典结构，但字段没有名称。要访问元组结构中的字段，请使用索引元组时所用的语法：.。与元组一样，元组结构中的索引值从0开始\n“单元结构”最常用作标记struct Student &#123;\n    name: String,\n    level: u8,\n    remote: bool\n&#125;\n\nstruct Grades(char, char, u8, f32);\n\nstruct Unit;\n\n创建和使用数组定义数组\n未指定长度的逗号分隔的值列表\n初始值后跟一个分号，然后是数组长度\n\n&#x2F;&#x2F; Declare array, initialize all values, compiler infers length &#x3D; 7\nlet days &#x3D; [&quot;Sunday&quot;, &quot;Monday&quot;, &quot;Tuesday&quot;, &quot;Wednesday&quot;, &quot;Thursday&quot;, &quot;Friday&quot;, &quot;Saturday&quot;];\n  \n&#x2F;&#x2F; Declare array, initialize all values to 0, length &#x3D; 5\nlet bytes &#x3D; [0; 5];\n\n在编译时，数组的签名定义为 [T; size]：\n\nT是数组中所有元素的数据类型\nsize是表示数组长度的非负整数\n\n该签名揭示有关数组的两个重要特征:\n\n数组的每个元素都具有相同的数据类型。 数据类型永远不会更改\n数组大小是固定的。 长度永远不会更改\n\n仅数组中元素的值可随时间而更改。 数据类型和元素数量（长度）均保持不变。 只有这些值可以更改\n读取数组的值数组中的元素从 0 开始隐式编号。 我们在表达式 &lt;array&gt;[&lt;index&gt;] 中使用索引来访问的数组中的元素。 例如，my_array[0] 访问 my_array 变量中索引 0 位置的元素。 该表达式返回该索引位置的数组元素的值\n&#x2F;&#x2F; Days of the week\nlet days &#x3D; [&quot;Sunday&quot;, &quot;Monday&quot;, &quot;Tuesday&quot;, &quot;Wednesday&quot;, &quot;Thursday&quot;, &quot;Friday&quot;, &quot;Saturday&quot;];\n\n&#x2F;&#x2F; Get the first day of the week\nlet first &#x3D; days[0];\n\n&#x2F;&#x2F; Get the second day of the week\nlet second &#x3D; days[1];\n\nVectorVector和数组一样，可以使用索引访问元素。mut 可变Vector添加元素可以使用 push函数，删除Vector最后一个元素可以使用 pop函数\nif elseRust中的if-else 语句块是可以充当表达式的\nlet formal &#x3D; true;\nlet greeting &#x3D; if formal &#123; &#x2F;&#x2F; if used here as an expression\n    &quot;Good day to you.&quot;     &#x2F;&#x2F; return a String\n&#125; else &#123;\n    &quot;Hey!&quot;                 &#x2F;&#x2F; return a String\n&#125;;\nprintln!(&quot;&#123;&#125;&quot;, greeting)   &#x2F;&#x2F; prints &quot;Good day to you.&quot;\n\n合并多个测试条件可以将if 和else 组合在一起形成else if 表达式。可以在开头的if 条件后面和else 条件前面使用多个else if条件，这些条件是可选的\n如果条件表达式的计算结果为true，则执行相应的操作块，跳过后面任何的else if 和else 块。如果条件表达式的结果为false ，则跳过相应的操作块。如果if 和 else if 条件的计算结果都是false，则执行所有的else 程序块\nlet num &#x3D; 500; &#x2F;&#x2F; num variable can be set at some point in the program\nlet out_of_range: bool;\nif num &lt; 0 &#123;\n    out_of_range &#x3D; true;\n&#125; else if num &#x3D;&#x3D; 0 &#123;\n    out_of_range &#x3D; true;\n&#125; else if num &gt; 512 &#123;\n    out_of_range &#x3D; true;\n&#125; else &#123;\n    out_of_range &#x3D; false;\n&#125;\n\n错误处理\n处理无法恢复的错误可以使用panic!\n如果值是可选或缺少值不是一种错误的情况，使用Option 枚举\n当可能出现问题并且调用方法必须处理问题时，使用Result 枚举\n\n使用Option类型来处理缺失Option&lt;T&gt; 将自身列为两个变体之一：\nenum Option&lt;T&gt; &#123;\n    None,     &#x2F;&#x2F; The value doesn&#96;t exist\n    Some(T),  &#x2F;&#x2F; The value exists\n&#125;\nOption&lt;T&gt; 枚举声明的&lt;T&gt; 部分声明类型T 是通用的，将与Option 枚举的Some 变体相关联\nNone 和Some不是类型，而是Option&lt;T&gt; 类型的变体。这表示在其他功能中，函数不能使用Some 或None 作为参数，而只能使用Option&lt;T&gt; 作为参数\n如何才能访问到Some(data) 变体中的数据呢？模式匹配Rust 中提供了一个功能强大的运算符，称为 match。 可利用该运算符，通过提供模式来控制程序流。 当 match 找到匹配的模式时，它会运行随该模式一起提供的代码\nlet fruits &#x3D; vec![&quot;banana&quot;, &quot;apple&quot;, &quot;coconut&quot;, &quot;orange&quot;, &quot;strawberry&quot;];\nfor &amp;index in [0, 2, 99].iter() &#123;\n    match fruits.get(index) &#123;\n        Some(fruit_name) &#x3D;&gt; println!(&quot;It&#39;s a delicious &#123;&#125;!&quot;, fruit_name),\n        None &#x3D;&gt; println!(&quot;There is no fruit! :(&quot;),\n    &#125;\n&#125;\n\nif let 表达式let a_number: Option&lt;u8&gt; &#x3D; Some(7);\nmatch a_number &#123;\n    Some(7) &#x3D;&gt; println!(&quot;That&#39;s my lucky number!&quot;),\n    _ &#x3D;&gt; &#123;&#125;,\n&#125;\n这种情况下，可以用所有其他模式之后添加_ 通配符，以匹配任何其他模式\n使用if let 压缩代码：\nlet a_number: Option&lt;u8&gt; &#x3D; Some(7);\nif let Some(7) &#x3D; a_number &#123;\n    println!(&quot;That&#39;s my lucky number!&quot;);\n&#125;\n\n使用unwrap 和expect可以使用unwrap 和expect 方法直接访问Option 类型的内部值。但是要小心，因为如果变体是None，则此方法会panic\n使用Result 类型来处理错误Rust提供了用于返回和传播错误的Result&lt;T, E&gt; 枚举。按照惯例，Ok(T) 变量表示成功并包含一个值，而变量Err(E) 表示错误并包含一个错误值\nenum Result&lt;T, E&gt; &#123;\n    Ok(T):  &#x2F;&#x2F; A value T was obtained.\n    Err(E): &#x2F;&#x2F; An error of type E was encountered instead.\n&#125;\n\n不同于描述缺少某个值的可能性Option 类型，Result 类型最适合在可能会失败的时候使用\nResult 类型还具有unwrap 和 expect 方法，这些方法执行以下操作之一：\n\n返回Ok 变量中的值\n如果变体是Err，则导致程序panic\n\n#[derive(Debug)]\nstruct DivisionByZeroError;\n\nfn safe_division(dividend: f64, divisor: f64) -&gt; Result&lt;f64, DivisionByZeroError&gt; &#123;\n    if divisor &#x3D;&#x3D; 0.0 &#123;\n        Err(DivisionByZeroError)\n    &#125; else &#123;\n        Ok(dividend &#x2F; divisor)\n    &#125;\n&#125;\n\nfn main() &#123;\n    println!(&quot;&#123;:?&#125;&quot;, safe_division(9.0, 3.0));\n    println!(&quot;&#123;:?&#125;&quot;, safe_division(4.0, 0.0));\n    println!(&quot;&#123;:?&#125;&quot;, safe_division(0.0, 2.0));\n&#125;\n\n内存管理Rust最强大的两个功能：所有权和借用\n什么是所有权？Rust包含用于管理内存的所有权系统。在编译时，所有权系统会检查一组规则，以确保所有权功能允许程序运行而不减慢速度\n作用域界定规则在Rust中，与大多数编程语言一样，变量仅在特定的作用域内有效。在Rust中，作用域常常由大括号&#123;&#125; 表示。常见的作用域还包括函数体、if、else 和match 分支\n在Rust中，“变量”通常称为“绑定”。这是因为Rust中的“变量”不是多变的，它们默认不可变，因此不会经常改变。相反，我们常常会想到与数据“绑定”的名称，所以称为“绑定”\n假设一个string 变量，它是在某个作用域内定义的一个字符串：\n&#x2F;&#x2F; &#96;string&#96; is not valid and cannot be used here, because it&#39;s not yet declared.\n&#123;\n    let string &#x3D; String::from(&quot;ferris&quot;);   &#x2F;&#x2F; &#96;string&#96; is valid from this point forward.\n    &#x2F;&#x2F; do stuff with &#96;string&#96;.\n&#125;\n&#x2F;&#x2F; this scope is now over, so &#96;string&#96; is no longer valid and cannot be used.\n如果尝试在string 的范围之外使用它，将会得到一下错误示例：\n&#123;\n    let string &#x3D; String::from(&quot;ferris&quot;);\n&#125;\nprintln!(&quot;&#123;&#125;&quot;, string);\nerror[E0425]: cannot find value `string` in this scope\n     --> src/main.rs:5:20\n      |\n    5 |     println!(\"&#123;&#125;\", string);\n      |                    ^^^^^^ not found in this scope\n\n所有权和删除Rust给范围的概念增加了一个转折。当对象超出范围时，便会将其“删除”。删除变量会释放与其关联的所有资源。对于文件的变量，文件最终会被关闭。对于已分配了与其关联的内存的变量，内存将被释放\n在Rust中，将绑定被删除时释放的内容与自己“关联”到一起的绑定将“拥有”这些内容\n在上一个例子中，string 变量拥有与之关联的String 数据。string 本身拥有堆分配的内存，其中包含该字符串的字符。在作用域的末尾，string 被“删除”，它拥有的String 被删除，最后String 拥有的内存被释放\n&#123;\n    let string &#x3D; String::from(&quot;ferris&quot;);\n    &#x2F;&#x2F; string dropped here. The String data memory will be freed here.\n&#125;\n\n移动语义有时，我们不希望在作用域末尾删除与变量的关联的内容。相反，我们希望将某个项的所有权从一个绑定转移到另一个绑定\n&#123;\n    let string &#x3D; String::from(&quot;ferris&quot;);\n    &#x2F;&#x2F; transfer ownership of string to the variable ferris.\n    let ferris &#x3D; string;\n    &#x2F;&#x2F; ferris dropped here. The string data memory will be freed here.\n&#125;\n需要了解一个关键问题，那就是所有权一旦转移，旧变量将不再有效。当我们将String 的所有权从 string 转移到 ferris 之后，将无法再使用string 变量\n如果我们尝试在将String 从string 移动到ferris 之后使用string，编译器将不会编译我们的代码：\nlet string &#x3D; String::from(&quot;hello world&quot;);\nlet ferris &#x3D; string;\n&#x2F;&#x2F; We&#39;ll try to use string after we&#39;ve moved ownership of the string data from string to ferris.\nprintln!(&quot;&#123;&#125;&quot;, string);\nerror[E0382]: borrow of moved value: `string`\n --> src/main.rs:4:20\n  |\n2 |     let string = String::from(\"ferris\");\n  |         ------ move occurs because `string` has type `String`, which does not implement the `Copy` trait\n3 |     let ferris = string;\n  |                  ------ value moved here\n4 |     println!(\"&#123;&#125;\", string);\n  |                    ^^^^^^ value borrowed here after move\n该结果被称为“移动后使用”编译错误\n在Rust中，一个项一次只能拥有一段数据\n函数中的所有权例子：将字符创作为参数传递给函数。将某个内容作为参数传递给函数，会将该内容移动到函数中\nfn process(input: String) &#123;&#125;\n\nfn caller() &#123;\n    let s &#x3D; String::from(&quot;hello world&quot;);\n    process(s); &#x2F;&#x2F; Ownership of the string in &#96;s&#96; moved into &#96;process&#96;\n    process(s); &#x2F;&#x2F; Error! ownership already moved.\n&#125;\n编译器提醒s 已被移动\nerror[E0382]: use of moved value: `s`\n     --> src/main.rs:6:13\n      |\n    4 |     let s = String::from(\"Hello, world!\");\n      |         - move occurs because `s` has type `String`, which does not implement the `Copy` trait\n    5 |     process(s); // Transfers ownership of `s` to `process`\n      |             - value moved here\n    6 |     process(s); // Error! ownership already transferred.\n      |             ^ value used here after move\n\n复制而不是移动fn process(input: u32) &#123;&#125;\n\nfn caller() &#123;\n    let n &#x3D; 1u32;\n    process(n); &#x2F;&#x2F; Ownership of the number in &#96;n&#96; copied into &#96;process&#96;\n    process(n); &#x2F;&#x2F; &#96;n&#96; can be used again because it wasn&#96;t moved, it was copied\n&#125;\n简单类型，如数字是“复制”类型。它们实现Copy 特征，这意味着它们被复制而不是移动。大多数简单类型都执行相同的操作。复制数字的成本低，因此复制这些值是有意义的。复制字符串、向量或其他复杂类型的成本可能高昂，因此它们没有实现Copy 特征，而是被移动\n复制不实现Copy 的类型解决上一个示例中所示错误的一种方法是：在移动类型之前，显式复制它们，这在Rust中称为克隆。调用.clone 会复制内存并生成一个新值。新值被移动，这意味着仍然可以使用旧值\nfn process(s: String) &#123;&#125;\n\nfn caller() &#123;\n    let s &#x3D; String::from(&quot;Hello world&quot;);\n    process(s.clone()); &#x2F;&#x2F; Passing another value, cloned from &#96;s&#96;\n    process(s); &#x2F;&#x2F; s was never moved and so it can still be used.\n&#125;\n这种方法可能有用，但会导致代码运行速度变慢，因此每次调用clone 都是对数据的一次完整复制。此方法通过包括内存分配或其他高成本的操作。可以使用引用来“借用”值，从而避免这些成本\n了解借用通过将所有权从一个变量转移到另一个变量来转移一个值的所有权。对于实现Copy 特征的类型，例如简单的值（如数字），所有权不能被转移\n还可以使用克隆过程显式复制值。调用clone 方法并获取复制的新值，这样原始值未被移动且仍可使用\n此类功能通过使用引用来提供，通过引用，可以“借用”一些值，而无需拥有它们\nlet greeting &#x3D; String::from(&quot;hello&quot;);\nlet greeting_reference &#x3D; &amp;greeting; &#x2F;&#x2F; We borrow &#96;greeting&#96; but the string data is still owned by &#96;greeting&#96;\nprintln!(&quot;Greeting: &#123;&#125;&quot;, greeting); &#x2F;&#x2F; We can still use &#96;greeting&#96;\ngreeting 是使用引用符号(&amp;) 借用的。变量greeting_reference 的类型为字符串引用(&amp;String)。由于只借用了greeting，并没有移动所有权，因此，在创建greeting_reference 之后仍然可以使用greeting\n函数中的引用fn print_greeting(message: &amp;String) &#123;\n    println!(&quot;Greeting: &#123;&#125;&quot;, message);\n&#125;\n\nfn main() &#123;\n    let greeting &#x3D; String::from(&quot;Hello&quot;);\n    print_greeting(&amp;greeting); &#x2F;&#x2F; &#96;print_greeting&#96; takes a &#96;&amp;String&#96; not an owned &#96;String&#96; so we borrow &#96;greeting&#96;\n    print_greeting(&amp;greeting); &#x2F;&#x2F; Since &#96;greeting&#96; didn&#39;t move into &#96;print_greeting&#96; we can use it again\n&#125;\n通过借用，无需完全拥有某个值即可使用它。不过，借用值意味着并不能像完全拥有值那样执行权限范围内的所有操作\n改变借用的值fn change(message: &amp;String) &#123;\n  message.push_str(&quot;!&quot;); &#x2F;&#x2F; We try to add a &quot;!&quot; to the end of our message\n&#125;\n\nfn main() &#123;\n  let greeting &#x3D; String::from(&quot;Hello&quot;);\n  change(&amp;greeting); \n&#125;\n代码不能通过编译。收到的错误是：\nerror[E0596]: cannot borrow `*message` as mutable, as it is behind a `&amp;` reference\n --> src/main.rs:2:3\n  |\n1 | fn change(message: &amp;String) &#123;\n  |                    ------- help: consider changing this to be a mutable reference: `&amp;mut String`\n2 |   message.push_str(\"!\"); // We try to add a \"!\" to the end of our message\n  |   ^^^^^^^ `message` is a `&amp;` reference, so the data it refers to cannot be borrowed as mutable\n\n借用和可变引用不可变引用和可变引用还有一个不同之处：会对我们生成Rust程序的方式有根本的影响。借用任何T 类型的值时，以下规则都适用：\n代码必须同时实现以下任一定义，但不能同时实现这两个定义：\n\n一个或多个不可变引用（&amp;T）\n恰好一个可变引用（&amp;mut T）\n\n使用生命周期验证引用fn main() &#123;\n    let x;\n    &#123;\n        let y &#x3D; 42;\n        x &#x3D; &amp;y; &#x2F;&#x2F; We store a reference to &#96;y&#96; in &#96;x&#96; but &#96;y&#96; is about to be dropped.\n    &#125;\n    println!(&quot;x: &#123;&#125;&quot;, x); &#x2F;&#x2F; &#96;x&#96; refers to &#96;y&#96; but &#96;y has been dropped!\n&#125;\n这段代码编译失败\nfn main() &#123;\n    let x;                &#x2F;&#x2F; ---------+-- &#39;a\n    &#123;                     &#x2F;&#x2F;          |\n        let y &#x3D; 42;       &#x2F;&#x2F; -+-- &#39;b  |\n        x &#x3D; &amp;y;           &#x2F;&#x2F;  |       |\n    &#125;                     &#x2F;&#x2F; -+       |\n    println!(&quot;x: &#123;&#125;&quot;, x); &#x2F;&#x2F;          |\n&#125;\n内层 &#39;b 块的生存期比外层 &#39;a 块的生存期更短\nRust 编译器可以使用借用检查器来验证借用是否有效。 借用检查器会在编译时比较两个生存期。 在此场景中，x 的生存期为 &#39;a，但它引用了生存期为 &#39;b 的值。 引用主体（生存期为 &#39;b 的 y）的生存期比引用（生存期为 &#39;a 的 x）的生存期短，因此程序不会进行编译\n另一个例子：\nfn main() &#123;\n    let magic1 &#x3D; String::from(&quot;abracadabra!&quot;);\n    let result;\n    &#123;\n        let magic2 &#x3D; String::from(&quot;shazam!&quot;);\n        result &#x3D; longest_word(&amp;magic1, &amp;magic2);\n    &#125;\n    println!(&quot;The longest magic word is &#123;&#125;&quot;, result);\n&#125;\n\nfn longest_word&lt;&#39;a&gt;(x: &amp;&#39;a String, y: &amp;&#39;a String) -&gt; &amp;&#39;a String &#123;\n    if x.len() &gt; y.len() &#123;\n        x\n    &#125; else &#123;\n        y\n    &#125;\n&#125;\n错误:\nerror[E0597]: `magic2` does not live long enough\n     --> src/main.rs:6:40\n      |\n    6 |         result = longest_word(&amp;magic1, &amp;magic2);\n      |                                        ^^^^^^^ borrowed value does not live long enough\n    7 |     &#125;\n      |     - `magic2` dropped here while still borrowed\n    8 |     println!(\"The longest magic word is &#123;&#125;\", result);\n      |                                              ------ borrow later used here\n此错误表明编译器预期 magic2 的生存期与返回值和 x 输入参数的生存期相同。 Rust 预料会出现这种行为，因为我们使用同一生存期名称 (&#39;a) 对函数参数和返回值的生存期进行了批注\n如果我们检查代码，作为人类，我们会看到 magic1 比 magic2 长。 我们会看到，结果包含对 magic1 的引用，该引用的生存期足够长，因此有效。 但是，Rust 在编译时无法运行该代码。 它会将 &amp;magic1 和 &amp;magic2 引用都视为可能的返回值，并会发出我们此前看到的错误\nlongest_word 函数返回的引用生存期与传入的引用生存期中较小者相匹配。 因此，代码可能包含无效引用，借用检查器将禁止该引用\nTraittrait Area &#123;\n    fn area(&amp;self) -&gt; f64;\n&#125;\n\nstruct Circle &#123;\n    radius: f64,\n&#125;\n\nstruct Rectangle &#123;\n    width: f64,\n    height: f64,\n&#125;\n\nimpl Area for Circle &#123;\n    fn area(&amp;self) -&gt; f64 &#123;\n        use std::f64::consts::PI;\n        PI * self.radius.powf(2.0)\n    &#125;\n&#125;\n\nimpl Area for Rectangle &#123;\n    fn area(&amp;self) -&gt; f64 &#123;\n        self.width * self.height\n    &#125;\n&#125;\n为实现某种类型的特征，使用关键字impl Trait for Type，其中Trait 是要实现的特征的名称，Type 是实现器结构体或枚举的名称\n在impl 块中，放置特征所需的方法签名，并使用自己希望特征的方法对于特定类型具有的特定行为填充方法主体\n迭代器trait Iterator &#123;\n    type Item;\n    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;\n&#125;\nIterator 具有方法next，调用时它将返回Option&lt;Item&gt;。只要有元素，next 方法就会返回Some(Item)。用尽所有元素后，它将会返回None 以指示迭代已完成\ntype Item 和 Self::Item，它们使用此特征定义关联的类型。此定义意味着Iterator 特征的每一次实现还需要定义关联的Item 类型，该类型用作next 方法的返回类型。换句话说，Item 类型将是从for 循环块内的迭代器返回的类型\n模块、包和第三方crate理解代码组织背后的概念\n包\n包含一个或多个crete内的功能\n包括有关如何生成这些crate的信息。该信息位于Cargo.toml 文件中\n\n\n箱\n是编译单元，即 Rust 编译器可以运行的最小码量\n编译完成后，系统将生成可执行文件或库文件\n其中包含未命名的隐式顶层模块\n\n\n模块\n是箱内的代码组织单位（或为嵌套形式）\n可以具有跨其他模块的递归定义\n\n\n\n程序包每当运行Cargo new &lt;project-name&gt; 命令时，Cargo将会为我们创建一个包\n板条箱Rust 的编译模型集中在名为箱 的项目中，可以将这些项目译为二进制文件或库文件\n使用cargo new 命令创建的每个项目本身都是箱。可以在项目中用作依赖项的所有第三方Rust 代码也是单个箱\n库文件箱创建库命令cargo new --lib\n模块Rust 具有功能强大的模块系统。该系统可以分层方式将代码拆分为逻辑单元，从而提高其可读性和重用性\n模块是项的集合：\n\n常量\n类型别名\n函数\n结构\n枚举\ntrait\nimpl 块\n其他模块\n\n模块还控制项隐私。项隐私将项标识为 public 和 private。public 表示项可以由外部代码使用。private 表示该项是内部实现详细信息，不能供外部使用\nmod math &#123;\n    type Complex &#x3D; (f64, f64);\n    pub fn sin(f: f64) -&gt; f64 &#123; &#x2F;* ... *&#x2F; &#125;\n    pub fn cos(f: f64) -&gt; f64 &#123; &#x2F;* ... *&#x2F; &#125;\n    pub fn tan(f: f64) -&gt; f64 &#123; &#x2F;* ... *&#x2F; &#125;\n&#125;\n\nprintln!(&quot;&#123;&#125;&quot;, math::cos(45.0));\n如果源文件中存在mod 声明，则在运行编译器之前，系统会将模块文件的内容插入到mod 声明的源文件中的所在位置。换句话说，系统不会对模块进行单独编译，只会编译箱\nRust 编译器会检查以确定是否可以跨模块使用项。默认情况下，Rust 中的所有内容都是专用的，并且只能由当前模块及其后代访问。与此相反，当项被声明pub 时，则可以将其视为可供外界访问\n&#x2F;&#x2F; Declare a private struct\nstruct Foo;\n\n&#x2F;&#x2F; Declare a public struct with a private field\npub struct Bar &#123;\n    field: i32,\n&#125;\n\n&#x2F;&#x2F; Declare a public enum with two public variants\npub enum State &#123;\n    PubliclyAccessibleVariant,\n    PubliclyAccessibleVariant2,\n&#125;\n\n向项目中添加第三方箱[dependencies]\nregex = \"1.4.2\"\n如果在Cargo.toml 没有[dependencies] 部分，手动添加该部分即可\n单元测试Rust中的单元测试是用#[test] 属性标记的简单函数，可用于验证非测试代码是否按照预期方式正常运行。系统仅会在测试代码时编译这些函数\n测试函数会运行要测试的代码。然后，这些函数通常使用assert! 或assert_eq! 宏来检查结果\nfn add(a: i32, b: i32) -&gt; i32 &#123;\n    a + b\n&#125;\n\n#[test]\nfn add_works() &#123;\n    assert_eq!(add(1, 2), 3);\n    assert_eq!(add(10, 12), 22);\n    assert_eq!(add(5, -2), 3);\n&#125;\n\n预期的失败使用should_panic，便可以检查panic!。如果将此属性添加到测试函数，则当函数中的代码崩溃时，测试便会通过。当代码不崩溃时，测试便会失败\n#[test]\n#[should_panic]\nfn add_fails() &#123;\n    assert_eq!(add(2, 2), 7);\n&#125;\n\n忽略测试可以使用#[ignore] 属性对带有#[test] 属性批注的函数进行批注。此属性会令系统在测试过程中跳过该测试函数\n#[test]\n#[ignore &#x3D; &quot;not yet reviewed by the Q.A. team&quot;]\nfn add_negatives() &#123;\n    assert_eq!(add(-2, -2), -4)\n&#125;\n\n测试模块大多数单元测试将进入带有#[cfg(test)] 属性的字模块\nfn add(a: i32, b: i32) -&gt; i32 &#123;\n    a + b\n&#125;\n\n#[cfg(test)]\nmod add_function_tests &#123;\n    use super::*;\n\n    #[test]\n    fn add_works() &#123;\n        assert_eq!(add(1, 2), 3);\n        assert_eq!(add(10, 12), 22);\n        assert_eq!(add(5, -2), 3);\n    &#125;\n\n    #[test]\n    #[should_panic]\n    fn add_fails() &#123;\n        assert_eq!(add(2, 2), 7);\n    &#125;\n\n    #[test]\n    #[ignore]\n    fn add_negatives() &#123;\n        assert_eq!(add(-2, -2), -4)\n    &#125;\n&#125;\ncfg 属性负责控制条件编译，并仅会在谓词为true 时编译其所附带的内容。每当执行cargo test 命令时，Cargo都会自动发出test 编译标志，因此，当我们运行测试时，该标志将会始终为true\nuse super::*; 声明是add_function_tests 模块内部代码访问外部模块中add 的必要条件\n写入文档测试通过Rust，可以将文档示例作为测试来执行。记录Rust库的主要方式是使用三斜杠/// 注释源代码，即熟知的文档注释。文档注释会写入到Markdown中，并支持其中的代码块，因此可以对这些代码块进行编译并将其用作测试\n若要尝试此功能，需要先创建一个新的库项目\ncargo new --lib r20-test-doc\n\n&#x2F;&#x2F;&#x2F; Generally, the first line is a brief summary describing the function.\n&#x2F;&#x2F;&#x2F;\n&#x2F;&#x2F;&#x2F; The next lines present detailed documentation. \n&#x2F;&#x2F;&#x2F; Code blocks start with triple backticks. The code has an implicit &#96;fn main()&#96; inside and &#96;extern crate &lt;cratename&gt;&#96;,  \n&#x2F;&#x2F;&#x2F; which means you can just start writing code.\n&#x2F;&#x2F;&#x2F;\n&#x2F;&#x2F;&#x2F; &#96;&#96;&#96;\n&#x2F;&#x2F;&#x2F; let result &#x3D; basic_math::add(2, 3);\n&#x2F;&#x2F;&#x2F; assert_eq!(result, 5);\n&#x2F;&#x2F;&#x2F; &#96;&#96;&#96;\npub fn add(a: i32, b: i32) -&gt; i32 &#123;\n    a + b\n&#125;\n与单元测试一样，如果文档测试未在运行时崩溃，则表示其顺利通过。若要验证某些结果，使用aeert! 宏来验证实际输出是否与预期相同。可以通过命令cargo test 调用此代码的测试套件\n写入集成测试单元和文档测试提供了简洁具体的测试。 但是，将 Crate 作为一个整体测试也是一种好办法。 然后，我们可以确认 Crate 的各代码部分是否按预期一起运行\n若要将 Crate 作为成体进行测试，可以使用集成测试。 Rust 测试套件支持这种类型的测试，该测试仅调用库的公共 API 包含的函数。 我们可以使用集成测试来检查代码在其他人员使用它时的工作情况\n这些测试的独特之处在于它们存在于单独的目录和文件中，因此它们可以在外部对库代码进行测试。 使用 Cargo 运行集成测试时，请将测试放在“tests”目录中。 Cargo 会运行此目录中的每个源文件。 在项目目录中创建测试，级别与你的 src 目录相同\n闭包三种Fn 特征\nFnOnce,该类型的闭包会拿走被捕获变量的所有权\nfn fn_once&lt;F>(func: F) \nwhere\n    F: FnOnce(usize) -> bool + Copy,\n&#123;\n    println!(\"&#123;func(3)&#125;\");\n    println!(\"&#123;func(4)&#125;\");\n&#125;\n\nfn main() &#123;\n    let x = vec![1, 2, 3];\n    fn_once(|z| &#123;z == x.len()&#125;)\n&#125;\n如果想强制闭包取得捕获变量的所有权,可以在参数列表前添加move关键字,这种用法通常用于闭包的生命周期大于捕获变量的生命周期,例如将闭包返回或移入其他线程\nuse std::thread;\n\nlet v = vec![1, 2, 3];\nlet handle = thread::spawn(move || &#123;\n    println(\"Here's a vector: &#123;:?&#125;\", v);\n&#125;);\nhandle.join().unwrap();\n\nFnMut,它以可变借用的方式捕获了环境中的值,因此可以修改该值\n\n\npub fn fn_mut() &#123;\n    let mut s = String::new();\n\n    // mut,update_string可变闭包\n    let mut update_string = |str| s.push_str(str);\n    update_string(\"hello\");\n\n    println!(\"&#123;:?&#125;\", s);\n&#125;\npub fn fn_mut1() &#123;\n    let mut s = String::new();\n    let update_string = |str| s.push_str(str);\n\n    // 编译器会自动推导出update_string闭包的类型\n    exec(update_string);\n    println!(\"&#123;:?&#125;\", s);\n&#125;\n\nfn exec&lt;'a, F: FnMut(&amp;'a str)>(mut f: F) &#123;\n    f(\"world\")\n&#125;\n\n\nFn特征,它以不可变借用的方式捕获环境中的值\n\npub fn fn_1() &#123;\n    let s = String::from(\"hello\");\n\n    let update_string = |chs| println!(\"&#123;&#125; &#123;&#125;\", s, chs);\n\n    exec1(update_string);\n&#125;\n\nfn exec1&lt;F: Fn(String)>(f: F) &#123;\n    f(\"world\".to_string())\n&#125;\n\nmove和Fn在上面,我们讲到了move关键字对于FnOnce特征的重要性,但实际上使用了move的闭包依然可能实现了Fn或FnMut特征\n因此,一个闭包实现了哪种Fn特征取决于该闭包如何使用被捕获的变量,而不是取决于闭包如何捕获它们.move本身强调的就是后者,闭包如何捕获变量:\nfn main() &#123;\n    let s = String::new();\n\n    let update_string =  move || println!(\"&#123;&#125;\",s);\n\n    exec(update_string);\n&#125;\n\nfn exec&lt;F: FnOnce()>(f: F)  &#123;\n    f()\n&#125;\n这个闭包中使用了move关键字,所以我们的闭包捕获了它,但是由于闭包对s的使用仅仅是不可变借用,因此该闭包实际上还实现了Fn特征.因为该闭包不仅仅实现了FnOnce特征\nfn main() &#123;\n    let s = String::new();\n\n    let update_string =  move || println!(\"&#123;&#125;\",s);\n\n    exec(update_string);\n&#125;\n\nfn exec&lt;F: Fn()>(f: F)  &#123;\n    f()\n&#125;\n\n三种Fn的关系实际上,一个闭包并不仅仅实现某一种Fn特征,规则如下:\n\n所有的闭包都自动实现了FnOnce特征,因此任何一个闭包都至少可以被调用一次\n没有移出所捕获变量的所有权的闭包自动实现了FnMut特征\n不需要对捕获变量进行改变的闭包自动实现了Fn特征\n\npub fn fn_all() &#123;\n    let s = String::from(\"Hello\");\n\n    let update_string = || println!(\"&#123;&#125;\", s);\n\n    exec_fn(update_string);\n    exec_fn_once(update_string);\n    exec_fn_mut(update_string);\n&#125;\n\nfn exec_fn_once&lt;F: FnOnce()>(f: F) &#123;\n    f()\n&#125;\n\nfn exec_fn_mut&lt;F: FnMut()>(mut f: F) &#123;\n    f()\n&#125;\n\nfn exec_fn&lt;F: Fn()>(f: F) &#123;\n    f()\n&#125;\n\n闭包作为函数返回值需要加上impl,或者使用智能指针(如Box)包裹返回\n// 编译报错\nfn factory(x:i32) -> impl Fn(i32) -> i32 &#123;\n\n    let num = 5;\n\n    if x > 1&#123;\n        move |x| x + num\n    &#125; else &#123;\n        move |x| x - num\n    &#125;\n&#125;\n\n// 改正\nfn factory(x:i32) -> Box&lt;dyn Fn(i32) -> i32> &#123;\n\n    let num = 5;\n\n    if x > 1&#123;\n        move |x| x + num\n    &#125; else &#123;\n        move |x| x - num\n    &#125;\n&#125;\n\n迭代器Iterator 和 IntoIterator的区别这两个其实很容易搞混.\nIterator就是迭代器特征,只有实现了它才能成为迭代器,才能调用next\nIntoIterator强调的是某一个类型如果实现了该特征,它可以通过into_iter, iter等方法变成一个迭代器\n消费者与适配器消费者是迭代器上的方法,它会消费掉迭代器中的元素,然后返回其类型的值,这些消费者都是有一个共同的特点:在它们的定义中,都依赖next方法来消费元素,因此这也是为什么迭代器要实现Iterator特征,而该特征必须要实现next方法的原因\n消费者适配器\n只要迭代器上的某个方法A在其内部调用了next方法,那么A就被称为消费性适配器:因为next方法会消耗掉迭代器上的元素,所以方法A的调用也会消耗掉迭代器上的元素\nfn main() &#123;\n    let v1 = vec![1, 2, 3];\n\n    let v1_iter = v1.iter();\n\n    let total: i32 = v1_iter.sum();\n\n    assert_eq!(total, 6);\n\n    // v1_iter 是借用了 v1，因此 v1 可以照常使用\n    println!(\"&#123;:?&#125;\",v1);\n\n    // 以下代码会报错，因为 `sum` 拿到了迭代器 `v1_iter` 的所有权\n    // println!(\"&#123;:?&#125;\",v1_iter);\n&#125;\n如代码注释中所说明的:在使用sum方法后,我们将无法再使用v1_iter,因为sum拿走了该迭代器的所有权:\nfn sum&lt;S>(self) -> S \nwhere\n    Self: Sized,\n    S: Sum&lt;Self::Item>,\n&#123;\n    Sum::sum(self)\n&#125;\n\n迭代器适配器\n既然消费者适配器是消费掉迭代器,然后返回一个值.那么迭代器适配器,顾名思义,会返回一个新的迭代器,这是实现链式方式方法调用的关键: v.iter().map().filter()...\n与消费者适配器不同,迭代器适配器是惰性的,意味着需要一个消费者适配器来收尾,最终将迭代器转换成一个具体的值:\nlet v1 = Vec&lt;u32> = vec![1, 2, 3];\nv1.iter().map(|x| x + 1);\n\n// 编译报错\nwarning: unused `Map` that must be used\n --> src/main.rs:4:5\n  |\n4 |     v1.iter().map(|x| x + 1);\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_must_use)]` on by default\n  = note: iterators are lazy and do nothing unless consumed // 迭代器 map 是惰性的，这里不产生任何效果\n这里的map方法是一个迭代器适配器,它是惰性的,不产生任何行为,因此我们还需要一个消费者适配器进行收尾:\nlet v1: Vec&lt;i32> = vec![1, 2, 3];\n\nlet v2: Vec&lt;_> = v1.iter().map(|x| x + 1).collect();\n\nassert_eq!(v2, vec![2, 3, 4]);\n\ncollect\n上面代码中, 使用了collect方法,该方法就是一个消费者适配器, 使用它可以将一个迭代器中的元素收集到指定类型中, 这里我们为v2标注了Vec&lt;_&gt;类型,就是为了告诉collect: 请把迭代器中的元素消费掉, 然后把值收集成Vec&lt;_&gt;类型, 至于为何使用_, 因为编译器会帮我们自动推导\n智能指针堆栈\n栈内存从高位地址向下增长，且栈内存是连续分配的\n在 Rust 中，main 线程的栈大小是 8MB，普通线程是 2MB，在函数调用时会在其中创建一个临时栈空间，调用结束后 Rust 会让这个栈空间里的对象自动进入 Drop 流程，最后栈顶指针自动移动到上一个调用栈顶，无需程序员手动干预，因而栈内存申请和释放是非常高效的\n与栈相反，堆上内存则是从低位地址向上增长，堆内存通常只受物理内存限制，而且通常是不连续的，因此从性能的角度看，栈往往比堆更高\n相比其它语言，Rust 堆上对象还有一个特殊之处，它们都拥有一个所有者，因此受所有权规则的限制：当赋值时，发生的是所有权的转移（只需浅拷贝栈上的引用或智能指针即可），例如以下代码：\nfn main() &#123;\n    let b = foo(\"world\");\n    println!(\"&#123;&#125;\", b);\n&#125;\n\nfn foo(x: &amp;str) -> String &#123;\n    let a = \"Hello, \".to_string() + x;\n    a\n&#125;\n\n堆栈的性能很多人可能会觉得栈的性能肯定比堆高，其实未必。 由于我们在后面的性能专题会专门讲解堆栈的性能问题，因此这里就大概给出结论：\n\n小型数据，在栈上的分配性能和读取性能都要比堆上高\n中型数据，栈上分配性能高，但是读取性能和堆上并无区别，因为无法利用寄存器或 CPU 高速缓存，最终还是要经过一次内存寻址\n大型数据，只建议在堆上分配和使用\n\nBox 的使用场景由于 Box 是简单的封装，除了将值存储在堆上外，并没有其它性能上的损耗。而性能和功能往往是鱼和熊掌，因此 Box 相比其它智能指针，功能较为单一，可以在以下场景中使用它：\n\n特意的将数据分配在堆上\n数据较大时，又不想在转移所有权时进行数据拷贝\n类型的大小在编译期无法确定，但是我们又需要固定大小的类型时\n特征对象，用于说明对象实现了一个特征，而不是某个特定的类型\n\nDrop互斥的Copy和Drop\n我们无法为一个类型同时实现Copy 和Drop 特征. 因为实现了Copy 的特征会被编译器隐式的复制, 因此非常难以预测析构函数执行的时间和频率. 因此这些实现了Copy 的类型无法拥有析构函数\n#[derice(Debug)]\nstruct Foo;\n\nimpl Drop for Foo &#123;\n    fn drop(&amp;mut self) &#123;\n        println!(\"Deopping Foo!\");\n    &#125;\n&#125;\n以上代码报错如下:\nerror[E0184]: the trait `Copy` may not be implemented for this type; the type has a destructor\n  --> src/main.rs:24:10\n   |\n24 | #[derive(Copy)]\n   |          ^^^^ Copy not allowed on types with destructors\n\n关于Rc的简单总结\nRc&#x2F;Arc 是不可变引用, 无法修改它指向的值, 只能进行读取, 如果要修改, 需要配合内部可变性RefCell 或互斥锁Mutex\n一旦最后一个拥有者消失, 则资源会自动被回收, 这个生命周期是在编译器就确定下来的\nRc 只能用于同一线程内部, 想要用于线程之间的对象共享, 需要使用Arc\nRc 是一个智能指针, 实现了Deref 特征, 因此无需先解开Rc 指针, 再使用里面的T, 而是可以直接使用T\n\nArc的性能损耗原子化可以带来线程安全, 但是都会伴随着性能损耗, 而且这种性能损耗还不小\nCellCell 和 RefCell 在功能上没有区别，区别在于 Cell 适用于 T 实现 Copy 的情况:\nuse std::cell::Cell;\nfn main() &#123;\n  let c = Cell::new(\"asdf\");\n  let one = c.get();\n  c.set(\"qwer\");\n  let two = c.get();\n  println!(\"&#123;&#125;,&#123;&#125;\", one, two);\n&#125;\n\n注意:\nCell 智能指针跟上面笔记的智能指针有点不太一样的用法, 如例子所示, 获取指针的值是使用get, 设置指针的值是使用set\n而且获取到值之后还可以设置值? 这个貌似是违背了Rust的借用规则? (应该是的(bushi))\n通过Cell::from_mut解决借用冲突在Rust1.37版本中新增了两个非常使用的方法:\n\nCell::from_mut，该方法将 &amp;mut T 转为 &amp;Cell\nCell::as_slice_of_cells，该方法将 &amp;Cell&lt;[T]&gt; 转为 &amp;[Cell]fn is_even(i: i32) -> bool &#123;\n    i % 2 == 0\n&#125;\n\nfn retain_even(nums: &amp;mut Vec&lt;i32>) &#123;\n    let mut i = 0;\n    for num in nums.iter().filter(|&amp;num| is_even(*num)) &#123;\n        nums[i] = *num;\n        i += 1;\n    &#125;\n    nums.truncate(i);\n&#125;\n\n// 解决办法\nfn retain_even(nums: &amp;mut Vec&lt;i32>) &#123;\n    let mut i = 0;\n    for j in 0..nums.len() &#123;\n        if is_even(nums[j]) &#123;\n            nums[i] = nums[j];\n            i += 1;\n        &#125;\n    &#125;\n    nums.truncate(i);\n&#125;\n\n// Cell解决\nuse std::cell::Cell;\n\nfn retain_even(nums: &amp;mut Vec&lt;i32>) &#123;\n    let slice: &amp;[Cell&lt;i32>] = Cell::from_mut(&amp;mut nums[..])\n        .as_slice_of_cells();\n\n    let mut i = 0;\n    for num in slice.iter().filter(|num| is_even(num.get())) &#123;\n        slice[i].set(num.get());\n        i += 1;\n    &#125;\n\n    nums.truncate(i);\n&#125;\n\nRefCell由于 Cell 类型针对的是实现了 Copy 特征的值类型，因此在实际开发中，Cell 使用的并不多，因为我们要解决的往往是可变、不可变引用共存导致的问题，此时就需要借助于 RefCell 来达成目的\n所有权, 借用规则与智能指针的对比:\n\n\n\nRust规则\n智能指针带来的额外规则\n\n\n\n一个数据只有一个所有者\nRc/Arc 让一个数据可以拥有多个所有者\n\n\n要么多个不可变借用, 要么一个可变借用\nRefCell 实现编译器可变, 不可变引用共存\n\n\n违背规则导致编译错误\n违背规则导致运行时panic\n\n\n可以看出, Rc/Arc 和RefCell 合在一起, 解决了Rust中严苛的所有权和借用规则带来的某些场景下难使用的问题. 但是它们并不是银弹, 例如RefCell 实际上并没有解决可变引用和不可变引用共存的问题, 只是将报错从编译期推迟到运行时, 从编译器错误变成了panic 异常:\nuse std::cell::RefCell;\n\nfn main() &#123;\n    let s = RefCell::new(String::from(\"hello, world\"));\n    let s1 = s.borrow();\n    let s2 = s.borrow_mut();\n\n    println!(\"&#123;&#125;,&#123;&#125;\", s1, s2);\n&#125;\nthread 'main' panicked at 'already borrowed: BorrowMutError', src/main.rs:6:16\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n但是依然会因为违背了借用规则导致了运行期panic\n当确信编译器误报但不知道如何解决时, 或者有一个引用类型, 需要被四处使用和修改然后导致借用关系难以管理时, 可以优先考虑使用RefCell\nRefCell简单总结\n与Cell用于可Copy的值不同, RefCell用于引用\nRefCell只是将借用规则从编译期推迟到程序运行期, 并不能帮你绕过这个规则\nRefCell适用于编译期误报或者一个引用被在多处代码使用, 修改以至于难于管理借用关系时\n使用RefCell时, 违背借用规则会导致运行期的panic\n\n选择Cell还是RefCell\nCell只适用于Copy类型, 用于提供值, 而RefCell用于提供引用\nCell不会panic, 而RefCell会\n\nRc + RefCell组合使用在Rust中, 一个常见的组合就是Rc 和RefCell 在一起使用, 前者可以实现一个数据拥有多个所有者, 后者可以实现数据的可变性: \nuse std::cell::RefCell;\nuse std::rc::Rc;\nfn main() &#123;\n    let s = Rc::new(RefCell::new(\"我很善变，还拥有多个主人\".to_string()));\n\n    let s1 = s.clone();\n    let s2 = s.clone();\n    // let mut s2 = s.borrow_mut();\n    s2.borrow_mut().push_str(\", oh yeah!\");\n\n    println!(\"&#123;:?&#125;\\n&#123;:?&#125;\\n&#123;:?&#125;\", s, s1, s2);\n&#125;\n\nCPU损耗\n对 Rc 解引用是免费的（编译期），但是 * 带来的间接取值并不免费\n克隆 Rc 需要将当前的引用计数跟 0 和 usize::Max 进行一次比较，然后将计数值加 1\n释放（drop） Rc 需要将计数值减 1， 然后跟 0 进行一次比较\n对 RefCell 进行不可变借用，需要将 isize 类型的借用计数加 1，然后跟 0 进行比较\n对 RefCell 的不可变借用进行释放，需要将 isize 减 1\n对 RefCell 的可变借用大致流程跟上面差不多，但是需要先跟 0 比较，然后再减 1\n对 RefCell 的可变借用进行释放，需要将 isize 加 1\n\n多线程并发编程CPU多核并行一定是并发, 反之并发只有在多核时才可能并行\n单核心并发关键在于: 快速轮换处理不同的任务, 给用户带来所有任务同时在运行的假象\n多核心并行当CPU核心增多到N时, 那么同一时间就能有N个任务被处理, 那么我们的并行度就是N, 相应的处理效率也就变成了单核心的N倍(实际情况并没有这么高)\n多核心并发当核心增多到N时, 操作系统同时进行的任务肯定远不止N个, 这些任务将被放入M个线程队列中, 接着交给N个CPU核心去执行, 最后实现了M:N的处理模型, 在这种情况下, 并发与并行是同时发生的, 所有用户任务从表面来看都是并发的运行, 但实际上, 同一时刻只有N个任务能被同时并行的处理\n\n如果某个系统支持两个或多个动作的同时存在, 那么这个系统就是一个并发系统\n如果某个系统支持两个或多个动作的同时执行, 那么这个系统就是一个并行系统\n\n在并发程序中可以同时拥有两个或多个线程. 这意味着, 如果程序在单核处理器上运行, 那么这两个线程将交替地换入或换出内存. 这些线程是同时&quot;存在&quot;的 – 每个线程都是处于执行过程中的某个状态. 如果程序能够并行执行, 那么就一定是运行在多核处理器上. 此时, 程序中的每个线程都将分配到一个独立的处理器核心上, 因此可以同时运行\n所以, &quot;并行&quot;概念是&quot;并发&quot;概念的一个子集. 也就是说, 编写一个拥有多线程或者进程的并发程序, 但如果没有多核处理器来执行这个程序, 那么就不能以并行的方式运行代码. 因此, 凡是在求解单个问题时涉及多个执行流程的编程模式或者执行行为, 都属于并发编程的范畴\n编程语言的并发模型\n由于操作系统提供了创建线程的API, 因此部分语言会直接调用该API来创建线程, 因此最终程序内的线程和该程序占用的操作系统线程相等, 一般称之为1:1线程模型, 例如Rust\n还有些语言的内部实现了自己的线程模型(绿色线程, 协程), 程序内部的M个线程最后会以某种隐射方式使用N个操作系统线程去运行, 因此称之为M:N现成模型, 其中M和N并没有特定的彼此限制关系. 一个典型的代表就是Go语言\n还有写语言使用了Actor模型, 基于消息传递进行并行, 例如Erlang语言\n\n绿色线程&#x2F;协程的视线会显著增大运行时的大小, 因此Rust只在标准库中提供了1:1的线程模型, 如果你愿意牺牲一些性能来换取更精确的线程控制以及更小的线程上下文切换成本, 那么可以使用Rust中的M:N模型, 这些模型由三方库提供了实现, 例如大名鼎鼎的tokio\n使用线程由于多线程的代码是同时运行的，因此我们无法保证线程间的执行顺序，这会导致一些问题：\n\n竞态条件(race conditions)，多个线程以非一致性的顺序同时访问数据资源\n死锁(deadlocks)，两个线程都想使用某个资源，但是又都在等待对方释放资源后才能使用，结果最终都无法继续执行\n一些因为多线程导致的很隐晦的 BUG，难以复现和解决\n\n多线程的性能创建线程的性能据不精确估算, 创建一个线程大概需要0.24毫秒, 随着线程的变多, 这个值会变得更大, 因此线程的创建耗时是不可忽略的, 只有当真的需要处理一个值得用线程去处理的任务时, 才使用线程, 一些鸡毛蒜皮的任务, 就无需创建线程了\n创建多少线程合适因为CPU的核心数限制, 当任务是CPU密集型时, 就算线程数超过CPU核心数, 也并不能帮你获得更好的性能, 因为每个线程的任务都可以轻松让CPU的某个核心跑满, 既然如此, 让线程数等于CPU核心数是最好的\n但是当你的任务大部分时间都处于阻塞状态时, 就可以考虑增加多线程数量, 这样当某个线程处于阻塞状态时, 会被切走, 进而运行其它的线程, 典型就是网络IO操作, 我们可以为每一个进来的用户连接创建一个线程去处理, 该连接绝大部分时间都是处于IO读取阻塞状态, 因此有限的CPU核心完全可以处理成百上千的用户连接线程, 但是事实上, 对于这种网络IO情况, 一般都不再使用多线程的方式了, 毕竟操作系统的线程数是有限的, 意味着并发数也很容易达到上限, 而且过多的线程也会导致线程上下文切换的代价过大, 使用async/await的M:N 并发模型, 就没有这个烦恼\n总结Rust 的线程模式是1:1模型, 因为Rust要保持尽量小的运行时\n使用thread::spawn来创建线程, 创建出的多个线程之间并不存在执行顺序关系, 因此代码逻辑千万不要依赖于线程间的执行顺序\nmain 线程若是结束, 则所有子线程都将被终止, 如果希望等待子线程结束后, 再结束main 线程, 需要使用创建线程时返回的句柄join 方法\n在线程中无法直接借用外部环境中的变量值, 因为新线程的启动时间和结束时间点是不确定的, 所以Rust 无法保证该线程中借用的变量在使用过程中依然是合法的. 可以使用move 关键字将变量的所有权转移给新的线程来解决此问题\n父线程结束后, 子线程仍在持续运行, 直到子线程的代码运行完成或者main 线程的结束\n线程间的消息传递多发送者, 单接受者标准库提供了通道std::sync::mpsc, 其中mpsc 是multiple producer, single consumer 的缩写, 代表了该通道支持多个发送者, 但是只支持唯一的接收者. 当然, 支持多个发送者也就意味着支持单个发送者\n同步和异步的通道Rust标准库的mpsc 通道其实氛围两种类型: 同步和异步\n异步通道上述的例子都是使用的异步通道: 无论接收者是否正在接收消息, 消息发送者在发送消息的时候都不会阻塞\nuse std::sync::mpsc;\nuse std::thread;\nuse std::time::Duration;\nfn main() &#123;\n    let (tx, rx)= mpsc::channel();\n\n    let handle = thread::spawn(move || &#123;\n        println!(\"发送之前\");\n        tx.send(1).unwrap();\n        println!(\"发送之后\");\n    &#125;);\n\n    println!(\"睡眠之前\");\n    thread::sleep(Duration::from_secs(3));\n    println!(\"睡眠之后\");\n\n    println!(\"receive &#123;&#125;\", rx.recv().unwrap());\n    handle.join().unwrap();\n&#125;\n\n同步通道与异步通道相反, 同步通道发送消息是阻塞的, 只有在消息被接收后才接触阻塞\nuse std::sync::mpsc;\nuse std::thread;\nuse std::time::Duration;\nfn main() &#123;\n    let (tx, rx)= mpsc::sync_channel(0);\n\n    let handle = thread::spawn(move || &#123;\n        println!(\"发送之前\");\n        tx.send(1).unwrap();\n        println!(\"发送之后\");\n    &#125;);\n\n    println!(\"睡眠之前\");\n    thread::sleep(Duration::from_secs(3));\n    println!(\"睡眠之后\");\n\n    println!(\"receive &#123;&#125;\", rx.recv().unwrap());\n    handle.join().unwrap();\n&#125;\n\n传输多种类型的数据可以使用枚举来实现\n但是有一点需要注意, Rust会按照枚举中占用内存最大的那个成员进行内存对齐, 这意味着就算传输的是枚举占用内存最小的成员, 它占用的内存依然和最大的成员相同, 因此会造成内存上的浪费\n线程同步: 锁, Condvar和信号量共享内存可以说是同步的灵魂, 因为消息传递的底层实际上也是通过共享内存来实现, 两者区别:\n\n共享内存相对消息传递能节省多次内存拷贝的成本\n共享内存的实现简洁的多\n共享内存的锁竞争更多\n\n消息传递适用的场景很多: \n\n需要可靠和简单的(简单不等于简洁)实现时\n需要模拟现实世界, 例如用消息去通知某个目标执行相应的操作时\n需要一个任务处理流水线(管道)时, 等等\n\n而使用共享内存(并发原语)的场景往往就比较简单粗暴: 需要简洁的实现以及更高的性能时\n总之, 消息传递类似一个单所有权的系统: 一个值同时只能有一个所有者, 如果另一个线程需要该值的所有权, 需要将所有权通过消息传递进行转移. 而共享内存类似于一个多所有权的系统: 多个线程可以同时访问同一个值\n互斥锁Mutex互斥锁Mutex(mutual exclusion)\nMutex让多个线程并发的访问同一个值变成了排队访问: 同一时间, 只允许一个线程A 访问该值, 其他线程需要等待A 访问完成之后才能继续\n单线程中使用Mutex:\nuse std::sync::Mutex;\n\nfn main() &#123;\n    // 使用`Mutex`结构体的关联函数创建新的互斥锁实例\n    let m = Mutex::new(5);\n\n    &#123;\n        // 获取锁，然后deref为`m`的引用\n        // lock返回的是Result\n        let mut num = m.lock().unwrap();\n        *num = 6;\n        // 锁自动被drop\n    &#125;\n\n    println!(\"m = &#123;:?&#125;\", m);\n&#125;\n\n多线程中使用Mutex:\nuse std::sync::&#123;Arc, Mutex&#125;;\nuse std::thread;\n\nfn main() &#123;\n    let counter = Arc::new(Mutex::new(0));\n    let mut handles = vec![];\n\n    for _ in 0..10 &#123;\n        let counter = Arc::clone(&amp;counter);\n        let handle = thread::spawn(move || &#123;\n            let mut num = counter.lock().unwrap();\n\n            *num += 1;\n        &#125;);\n        handles.push(handle);\n    &#125;\n\n    for handle in handles &#123;\n        handle.join().unwrap();\n    &#125;\n\n    println!(\"Result: &#123;&#125;\", *counter.lock().unwrap());\n&#125;\n\n内部可变性Rc 和 RefCell的结合, 可以实现单线程的内部可变性\n由于Mutex 可以支持修改内部数据, 当结合Arc 一起使用, 可以实现多线程的内部可变性\n简单总结: Rc&#x2F;RefCell 用于单线程内部可变性, Arc&#x2F;Mutex 用于多线程内部可变性\n需要小心使用Mutex\n在使用数据前必须先获取锁\n在数据使用完成后, 必须及时的释放锁, 比如文章开头的例子, 使用内部语句块的目的就是为了及时释放锁\n\n读写锁RwLockMutex 会对每次读写都进行加锁, 但某些时候, 我们需要大量的并发读, Mutex 就无法满足需求, 此时就可以使用RwLock\nuse std::sync::RwLock;\n\nfn main() &#123;\n    let lock = RwLock::new(5);\n\n    // 同一时间允许多个读\n    &#123;\n        let r1 = lock.read().unwrap();\n        let r2 = lock.read().unwrap();\n        assert_eq!(*r1, 5);\n        assert_eq!(*r2, 5);\n    &#125; // 读锁在此处被drop\n\n    // 同一时间只允许一个写\n    &#123;\n        let mut w = lock.write().unwrap();\n        *w += 1;\n        assert_eq!(*w, 6);\n\n        // 以下代码会阻塞发生死锁，因为读和写不允许同时存在\n        // 写锁w直到该语句块结束才被释放，因此下面的读锁依然处于`w`的作用域中\n        // let r1 = lock.read();\n        // println!(\"&#123;:?&#125;\",r1);\n    &#125;// 写锁在此处被drop\n&#125;\n\n\n同时允许多个读, 但是最多只能有一个写\n读和写不能同时存在\n读可以使用read try_read, 写write try_write, 在实际项目中, try_xxx 会安全很多\n\nMutex还是RwLock首先简单性上Mutex完胜, 因为使用RwLock得操心几个问题:\n\n读和写不能同时发生, 如果使用try_xxx解决, 就必须做大量的错误处理和失败重试机制\n当读多写少时, 写操作可能会因为一直无法获得锁导致连续失败多次(Write starvation)\nRwLock其实是操作系统提供的, 实现原理要比Mutex复杂得多, 因此单就锁的性能而言, 比不上原生实现的Mutex\n\n再来简单总结下两者的使用场景:\n\n追求高并发读取时, 使用RwLock, 因为Mutex一次只允许一个线程去读取\n如果要保证写操作的成功性, 使用Mutex\n不知道哪个适合, 统一使用Mutex\n\n","categories":["笔记"],"tags":["Rust"]},{"title":"编译C3C源码","url":"/2025/03/20/%E7%BC%96%E8%AF%91C3C%E6%BA%90%E7%A0%81/","content":"前言关于 c3c 从源码构建, 遇到的一些坑: 当前 (2025-03-21) 根据 c3c 文档中介绍的从源码构建, 简单的几行命令就可以 build 出来编译器了, 但我在实际的操作中, 一直卡在 Loading Windows LLVM libraries, this may take a while..., 重试几次无果, 于是乎翻构建脚本看看\n准备目标平台是 windows, 其他平台不在此笔记中记载\n\n因为我主力机是 windows, 所以 Unix 系列没去 build, 听群友说是无痛编译\n\n开始之前列举一下相关文档:\n\nc3官方文档, 安装, 使用的详情都在这了\nc3文档指向的 llvm 版本, 我是直接到 llvm仓库自己安装的\nc3源码, git clone git@github.com:c3lang/c3c.git\n\nbuild前需要准备的环境如下:\n\nmsvc, 「visual studio installer」 中勾选上 「使用 C++ 的桌面开发」 安装即可 (这里如果不适用 msvc, 改用 mingw 应该也可以, 但是我没有实践)\ncmake\n\n构建\n直接跳到 补充 段落修改编译脚本(简单省事), 然后再根据下面的命令执行步骤跑一遍就可以了\n\n\ngit clone &#x67;&#x69;&#x74;&#64;&#103;&#105;&#x74;&#104;&#x75;&#x62;&#46;&#x63;&#111;&#x6d;:c3lang&#x2F;c3c.git\ncd c3c\n修改 CMakeLists.txt\nline: 121 ~ 152  # if(CMAKE_C_COMPILER_ID STREQUAL \"MSVC\")\n#     if (C3_LLVM_VERSION STREQUAL \"auto\")\n#         set(C3_LLVM_VERSION \"19\")\n#     endif()\n#     FetchContent_Declare(\n#             LLVM_Windows\n#             URL https://github.com/c3lang/win-llvm/releases/download/llvm_19_1_5/llvm-19.1.5-windows-amd64-msvc17-libcmt.7z\n#     )\n#     FetchContent_Declare(\n#             LLVM_Windows_debug\n#             URL https://github.com/c3lang/win-llvm/releases/download/llvm_19_1_5/llvm-19.1.5-windows-amd64-msvc17-libcmt-dbg.7z\n#     )\n#     if(CMAKE_BUILD_TYPE STREQUAL \"Debug\")\n#         message(\"Loading Windows LLVM debug libraries, this may take a while...\")\n#         FetchContent_MakeAvailable(LLVM_Windows_debug)\n#         set(llvm_dir $&#123;llvm_windows_debug_SOURCE_DIR&#125;)\n#     else()\n#         message(\"Loading Windows LLVM libraries, this may take a while...\")\n#         FetchContent_MakeAvailable(LLVM_Windows)\n#         set(llvm_dir $&#123;llvm_windows_SOURCE_DIR&#125;)\n#     endif()\n#     set(CMAKE_SYSTEM_PREFIX_PATH $&#123;llvm_dir&#125; $&#123;CMAKE_SYSTEM_PREFIX_PATH&#125;)\n\n#     find_package(LLVM REQUIRED CONFIG)\n#     find_package(LLD REQUIRED CONFIG)\n# else()\n#     if (NOT C3_LLVM_VERSION STREQUAL \"auto\")\n#         find_package(LLVM $&#123;C3_LLVM_VERSION&#125; REQUIRED CONFIG)\n#     else()\n#         find_package(LLVM REQUIRED CONFIG)\n#     endif()\n# endif()\n上面部分 cmake 脚本是默认 msvc 环境下就会去远端拉取 llvm 环境, 注释掉或者直接删除, 替换成下面的脚本. 其中 LLVM_DIR 设置成自己 llvm 实际的安装路径即可  if(CMAKE_C_COMPILER_ID STREQUAL \"MSVC\")\n    if (C3_LLVM_VERSION STREQUAL \"auto\")\n        set(C3_LLVM_VERSION \"19.1.5\")\n    endif()\n\n    # 手动设置本地 LLVM\n    set(LLVM_DIR \"D:/LLVM\" CACHE PATH \"Path to LLVM cmake directory\")\n    find_package(LLVM $&#123;C3_LLVM_VERSION&#125; REQUIRED CONFIG)\n    find_package(LLD REQUIRED CONFIG)\nelse()\n    if (NOT C3_LLVM_VERSION STREQUAL \"auto\")\n        find_package(LLVM $&#123;C3_LLVM_VERSION&#125; REQUIRED CONFIG)\n    else()\n        find_package(LLVM REQUIRED CONFIG)\n    endif()\nendif()\n\n\nmkdir build\ncd build\ncmake ..\ncmake –build .\n\n构建完毕, build 目录下生成 c3c.exe\n补充莫名奇妙的, 第二天到公司电脑编源码, 还是一样的配置 环境, 硬是不行 (找不到问题, 后面把 CMakeLists.txt 一通乱改测试编译), 后面发现没必要改这么一大段, 简单替换一下 fetch 部分就好了:\n\n我就只下载了一个 debug 的 llvm, 所以替换成一样的了\n\nif(CMAKE_BUILD_TYPE STREQUAL \"Debug\")\n    message(\"Loading Windows LLVM debug libraries, this may take a while...\")\n    # FetchContent_MakeAvailable(LLVM_Windows_debug)\n    set(llvm_dir \"D:/llvm-19.1.5-windows-amd64-msvc17-libcmt-dbg\" CACHE PATH \"Path to LLVM cmake directory\")\n    set(llvm_dir $&#123;llvm_windows_debug_SOURCE_DIR&#125;)\nelse()\n    message(\"Loading Windows LLVM libraries, this may take a while...\")\n    # FetchContent_MakeAvailable(LLVM_Windows)\n    set(llvm_dir \"D:/llvm-19.1.5-windows-amd64-msvc17-libcmt-dbg\" CACHE PATH \"Path to LLVM cmake directory\")\n    set(llvm_dir $&#123;llvm_windows_SOURCE_DIR&#125;)\nendif()\n\n测试还是在 build 目录中\nc3c compile-run  ../resources/testfragments/helloworld.c3\n\n打印输出如下, 即 c3c 环境搭建完成\nE:\\Code\\c3c\\build>c3c compile-run  ../resources/testfragments/helloworld.c3\nLaunching helloworld.exe\nHello, World!\nProgram completed with exit code 0.\n","categories":["笔记"],"tags":["C3C","C3"]}]